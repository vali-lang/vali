
@ignore_access_types

use utils

struct Request {
    method: String ("GET")
    path: String ("/")
    body: String ("")

    -ns header_data: utils:ByteBuffer (utils:ByteBuffer.new(1024))
    -ns params_data: String ("")
    -ns header_map: ?Map[String] (null)
    -ns params_map: ?Map[String] (null)
    -ns params_grp: ?Map[Array[String]] (null)
    -ns data_map: ?Map[String] (null)
    -ns files_map: ?Map[String] (null)

    response: Response (Response.text(""))

    fn reset() {
        this.method = "GET"
        this.path = ""
        this.body = ""

        this.header_data.clear()
        this.params_data = ""
        this.header_map = null
        this.params_map = null
        this.params_grp = null
        this.data_map = null
        this.files_map = null

        this.response.reset()
    }

    fn headers() Map[String] {
        let headers = this.header_map
        if isset(headers) : return headers
        let new = this.parse_headers()
        this.header_map = new
        return new
    }

    fn params() Map[String] {
        let params = this.params_map
        if isset(params) : return params
        let new = map[String]{}
        let data = this.params_data
        if data.bytes > 0 {
            let parts = data.split("&")
            each parts as part {
                let k, v = part.split_on_first_occurance_of_byte('=') ! continue
                new.set(k, url_decode(v))
            }
        }
        this.params_map = new
        return new
    }

    fn params_grouped() Map[Array[String]] {
        let params = this.params_grp
        if isset(params) : return params
        let new = map[Array[String]]{}
        let data = this.params_data
        if data.bytes > 0 {
            let parts = data.split("&")
            each parts as part {
                let k, v = part.split_on_first_occurance_of_byte('=') ! continue
                let arr = new.get(k) ! {
                    new.set(k, array[String]{ url_decode(v) })
                    continue
                }
                arr.push(url_decode(v))
            }
        }
        this.params_grp = new
        return new
    }

    fn data() Map[String] {
        let data = this.data_map
        if isset(data) : return data
        let new = map[String]{}
        let headers = this.headers()
        let type = headers.get("content-type") ? ""
        if type == "application/x-www-form-urlencoded" {
            this.data_urlencoded(new)
        } else if type.starts_with("multipart/form-data") {
            this.data_multipart(new)
        } else if type == "application/json" {
            this.data_json(new)
        }
        this.data_map = new
        return new
    }

    - fn data_urlencoded(data: Map[String]) {
        // TODO
    }
    - fn data_multipart(data: Map[String]) {
        // TODO
    }
    - fn data_json(data: Map[String]) {
        // TODO
    }

    - fn parse_headers() Map[String] {
        let headers = map[String]{}

        let pos : uint = 0
        let data = this.header_data
        let bytes = data.data
        let length = data.length

        while true {
            let index = data.index_of_byte('\r', pos) ! break
            if index + 1 == length : break
            if @ptrv(bytes, u8, index + 1) != '\n' : break

            // End of headers
            if index == pos : break

            let split = data.index_of_byte(':', pos) ! break
            if split > index : break
            while @ptrv(bytes, u8, split + 1) == ' ' {
                split++;
            }

            let key = data.sub_str(pos, split - pos);
            let value = data.sub_str(split + 1, index - split - 1);
            headers.set(key.to_lower(), value);

            pos = index + 2
        }

        return headers
    }
}
