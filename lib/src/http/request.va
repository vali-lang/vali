
use utils

class Request {
    headers: Map[String] (map[String]{})
    method: String ("GET")
    path: String ("/")
    body: String ("")
    response: Response (Response.text(""))
    uploads: Map[String] (map[String]{})

    fn reset() {
        this.headers.clear()
        this.method = "GET"
        this.path = ""
        this.body = ""
        this.uploads.clear()
        this.response.reset()
    }
}

class RequestParser {
    stage: uint (0)
    input: utils:ByteBuffer (utils:ByteBuffer.new(8192))
    input_pos: uint (0)
    content_length: uint (0)
    parsed_headers: bool (false)
    parsed_body: bool (false)

    fn full_reset() {
        this.input_pos = 0
        this.input.clear()
        this.soft_reset()
    }

    fn soft_reset() {
        let input = this.input
        let pos = this.input_pos
        if pos == input.length {
            this.input_pos = 0
            input.clear()
        }
        this.stage = 0
        this.content_length = 0
        this.parsed_headers = false
        this.parsed_body = false
    }

    fn parse(request: Request) !invalid !http413{

        if this.parsed_body {
            throw invalid
        }

        let input = this.input
        let pos = this.input_pos

        let stage = this.stage
        let data = input.data
        let length = input.length

        // Header
        if stage == 0 {
            let index = input.index_of_byte('\r', pos) ! {
                if input.length - pos > 4096 {
                    throw http413
                }
                return
            }
            if index + 1 == length { return }
            if @ptrv(data, u8, index + 1) != '\n' { throw invalid }

            let space1 = input.index_of_byte(' ', pos) ! { throw invalid }
            let space2 = input.index_of_byte(' ', space1 + 1) ! { throw invalid }

            if space1 > index { throw invalid }
            if space2 > index { throw invalid }

            // Request "GET / HTTP/1.1"
            let method = input.sub_str(pos, space1)
            let path = input.sub_str(space1 + 1, space2 - space1 - 1)
            // let version = input.sub_str(space2 + 1, index - space2 - 1)

            request.method = method;
            request.path = path;

            pos = index + 2;
            this.input_pos = pos;
            stage = 1;
            this.stage = stage;
        }

        // Headers
        let headers = request.headers;
        while stage == 1 {
            let index = input.index_of_byte('\r', pos) ! {
                if input.length - pos > 4096 {
                    throw http413
                }
                return
            }
            if index + 1 == length { return }
            if @ptrv(data, u8, index + 1) != '\n' { throw invalid }

            if index == pos {
                // End of headers
                pos = index + 2
                this.input_pos = pos;
                stage = 2;
                this.stage = stage;
                this.parsed_headers = true
                break;
            }

            let split = input.index_of_byte(':', pos) ! { throw invalid }
            if split > index { throw invalid }
            while @ptrv(data, u8, split + 1) == ' ' {
                split++;
            }

            let key = input.sub_str(pos, split - pos - 1);
            let value = input.sub_str(split + 1, index - split - 1);
            headers.set(key.to_lower(), value);

            // let key_len = split - pos - 1
            // let value_len = index - split - 1
            // if key_len > 2083 || value_len > 2083 : throw http413

            // let hbuffer = result.header_buffer
            // let headers_length = hbuffer.length + key_len + value_len + 2
            // if headers_length > 8192 : throw http413

            // let hbuf = result.header_sbuf
            // mem:copy(buffer.data + pos, hbuf.data, key_len)
            // @ptrv(hbuf.data, u8, key_len) = 0

            // hbuf.modify_to_lower()
            // if hbuf == "content-length" {
            //     mem:copy(buffer.data + split + 1, hbuf.data, value_len)
            //     @ptrv(hbuf.data, u8, value_len) = 0
            //     let content_len = hbuf.to_uint() ! {
            //         throw invalid;
            //     }
            //     result.content_length = content_len
            // }

            pos = index + 2
            this.input_pos = pos;
        }

        if stage == 2 {
            let content_len = this.content_length
            let bytes_left = length - pos;
            if bytes_left < content_len {
                return
            }

            let body = input.sub_str(pos, content_len);

            pos += content_len;
            this.parsed_body = true
            request.body = body;
            this.stage = 3;

            this.input_pos = pos;
        }
    }
}
