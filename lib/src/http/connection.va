
header "sys" as sys

use io
use net
use utils
use fs

class Connection {
    server: Server
    netcon: net:Connection
    fd: uint
    // uploads: ?Array[String] (null)
    read_buf: utils:ByteBuffer (utils:ByteBuffer.new(500))
    parse_result: ParseResult (ParseResult{})
    parse_pos: uint (0)
    added_active_body_size: bool (false)

    // Response
    out_file: ?fs:FileStream (null)
    out_buf: utils:ByteBuffer (utils:ByteBuffer.new(500))
    out_pos: uint (0)

    fn reset_parser() {
        //
        this.parse_result.clear()

        let read_buf = this.read_buf
        if read_buf.read_index == read_buf.length {
            read_buf.clear()
        }
    }

    fn reset_out() void {
        let file = this.out_file
        if isset(file) {
            file.close()
            this.out_file = null
        }
        this.out_buf.clear()
        this.out_pos = 0
    }

    fn send_file(stream: fs:FileStream, filename: ?String) void {

    	let out = this.out_buf
    	let path = stream.path
    	let fsize = fs:size(path)
    	let ext = fs:ext(path)
    	let mime = fs:mime(ext)

    	this.out_file = stream

    	out.append_str("HTTP/1.1 200 OK\r\nContent-Type: " + mime + "\r\nContent-Length: " + fsize + "\r\n")

    	if isset(filename) {
    		out.append_str("Content-Disposition: attachment filename=\"" + filename + "\"\r\n")
    	}

    	out.append_str("\r\n")
    }

    fn has_data_to_send() bool {
        if this.out_pos < this.out_buf.length {
            return true
        }
        let file = this.out_file
        if isset(file) { if file.reading : return true
        }
        return false
    }
    fn count_bytes_to_send() uint {
        return this.out_buf.length - this.out_pos
    }

    // Rewrite
    fn recv_and_respond() !recv !parse !send !request_size {
        let buffer = this.read_buf
        let result = this.parse_result
        let server = this.server
        let max_hs = server.max_request_header_size
        let max_bs = server.max_request_body_size
        let max_sbs = server.max_server_wide_body_size

        while true {
            // While our out buffer > 128k, send response
            while this.count_bytes_to_send() > (128 * 1024) || this.out_file != null {
                this.send_response_bytes() err ! {
                    if error_is(err, !again) : return
                    throw send, "Failed sending data to connection"
                }
            }
            // Our out buffer is less than 128k, allow to receive more data

            // Read bytes
            let bytes = this.netcon.recv(buffer) err ! {
                if error_is(err, !again) : break
                throw recv, "Failed receiving data from connection"
            }
            if bytes == 0 : break

            Parser.parse_bytes(buffer, result, false, true) err ! {
                buffer.clear()
                if error_is(err, !http413) {
                    throw request_size, "Request header size"
                }
                throw parse, "Parse error"
            }
            buffer.clear()

            if result.has_parsed_headers {
                let len = result.content_length
                if len > 0 {
                    if len > max_bs {
                        throw request_size, "Request body size"
                    }
                    if server.active_body_size + len > max_sbs {
                        throw request_size, "Request body size / Server capacity"
                    }
                    if !this.added_active_body_size {
                        this.added_active_body_size = true
                        atomic(server.active_body_size + len)
                    }
                }
            }

            if result.has_parsed_body {
                if this.added_active_body_size {
                    this.added_active_body_size = false
                    atomic(server.active_body_size - result.content_length)
                }

                if server.static_dirs.length > 0 {
                    let path = result.path.trim("/")
                    each server.static_dirs as dir {
                        let fullpath = dir + path 
                        if fs:is_file(fullpath) {
                            let stream = fs:stream(fullpath, true, false) ! continue
                            this.send_file(stream, null)
                            return
                        }
                    }
                }

                // Request
                let req = Request{
                    headers: result.headers,
                    method: result.method,
                    body: result.body,
                    path: result.path,
                }
                // Response
                let resp = server.handler(req)
                this.respond(resp)

                // Delete uploads
                // TODO
            }
        }

        this.send_response_bytes() err ! {
            if error_is(err, !again) : return
            throw send, "Failed sending data to connection"
        }
    }

    fn respond(resp: Response) void {
        let filepath = resp.filepath
        if isset(filepath) {
        	let stream = fs:stream(filepath, true, false) ! {
        		this.respond(Response.error(404))
        		return
            }
            this.send_file(stream, resp.filename)
        	return
        }

        resp.compile(this.out_buf)
    }

    fn send_response_bytes() !write !again {

        let out = this.out_buf
        let file = this.out_file

        while true {
            // Check file stream
            if isset(file) {
                if this.count_bytes_to_send() == 0 {
                    if file.reading {
                        let part = file.read(65535) ? ""
                        out.append_str(part)
                    }
                }
            }

            let pos = this.out_pos
            let bytes = out.length - pos
            if bytes == 0 : break

            let wbytes = this.netcon.send_from_ptr(out.data + pos, bytes) err ! {
                if error_is(err, !again) : throw again
                throw write
            }
            this.out_pos += wbytes
        }

        this.reset_out()
    }

    fn close() {
        if this.added_active_body_size {
            atomic(this.server.active_body_size - this.parse_result.content_length)
            this.added_active_body_size = false
        }
        this.reset_out()
        this.reset_parser()
        net:Socket.close(this.fd)
    }

}


