
header "sys" as sys

use os
use net
use io
use fs

fn test(req: Request) Response {
    return Response.html("Hello world!")
}

class Server {
    - host: String
    - port: u16
    - socket: net:SocketTCP
    - max_connections: uint
    -- handler: fn(Request)(Response) (test)
    -- static_dirs: Array[String] (Array[String].new())
    ~~ active_body_size: uint (0)
    max_request_header_size: uint (8 * 1024) // 8 KB
    max_request_body_size: uint (32 * 1024 * 1024) // 32 MB
    max_server_wide_body_size: uint (2 * 1024  @as uint) // 2 GB
    show_info: bool (false)

    static fn new(host: String, port: u16, handler: fn(Request)(Response)) Server !socket_init_error !socket_bind_error {

        let max_connections : uint = 10000
        let socket = net:Socket.new_tcp(host, port, false) ! { throw socket_init_error }
        socket.bind() ! {
            throw socket_bind_error
        }

        return Server{
            host: host,
            port: port,
            socket: socket,
            max_connections: max_connections,
            handler: handler,
        }
    }

    fn start(worker_count: i32 (16)) void {

        // SIGINT
        os:signal(1, interrupt)
        // SIGPIPE
        os:signal_ignore(13)

        if worker_count < 1 {
            worker_count = 1
        }
        if worker_count > 128 {
            worker_count = 128
        }

        if this.show_info {
            println("[+] Running http server on port " + this.port)
            println("[+] Worker count: " + worker_count)
        }

        worker_count--
        while worker_count > 0 {
            // break
            let thread = os:Thread.start_with_data(Server.worker, this)
            worker_count--
        }

        this.worker()
        os:sleep_ms(200)
    }

    - async fn worker() {

        let max_connections = this.max_connections
        let handler = this.handler

        let sock = this.socket
        let sock_fd = sock.fd

        let poll = io:Poll[?Connection].new() ! {
            println("[x] Failed to create poll instance")
            return
        }
        let sock_lsn = poll.create_listener(sock_fd, null)
        sock_lsn.detect_read_request(true)

        while true {
            let events = poll.wait(-1)
            let event_count = events.length
            let i : uint = 0

            while i < event_count {
                let lsn = events.get(i) ! { break }
                let fd = lsn.fd
                i++

                if fd == sock_fd {
                    // New connection
                    let netcon = await sock.accept() ! {
                        // print("failed to accept\n")
                        continue
                    }

                    let fd = netcon.fd
                    if this.show_info {
                        println("[+] New connection: " + fd)
                    }

                    let http_con = Connection {
                        server: this,
                        netcon: netcon,
                        fd: fd,
                    }

                    let lsn = poll.create_listener(fd, http_con)
                    lsn.detect_read_request(true)
                    lsn.detect_write_request(false)
                    continue
                }

                if lsn.data == null {
                    if this.show_info {
                        println("[x] Missing http connection for fd: " + lsn.fd)
                    }
                    net:Socket.close(lsn.fd)
                    continue
                }

                let http_con = lsn.data @as Connection
                if http_con.fd != fd {
                    if this.show_info {
                        print("[x] fd mismatch\n")
                    }
                    http_con.close()
                    net:Socket.close(fd)
                    continue
                }

                // Existing connection
                if lsn.has_stopped_the_connection() {
                    if this.show_info {
                        println("[+] Close connection: " + fd)
                    }
                    http_con.close()
                    continue
                }

                let read = lsn.has_read_request()
                let write = lsn.has_write_request()

                if !read && !write {
                    http_con.close()
                    continue
                }

                http_con.handle_event(read, write)
                if http_con.has_data_to_send() {
                    lsn.detect_write_request(true)
                } else {
                    lsn.detect_write_request(false)
                }
            }
        }
    }

    fn add_static_dir(path: String, relative_to_exe: bool (false)) void {
        let full = path
        if relative_to_exe {
            full = fs:exe_dir() + "/" + path.trim("/")
        }
        full = full.rtrim("/") + "/"
        if this.show_info {
            println("[+] Add static dir: " + full)
        }
        this.static_dirs.push(full)
    }
}

global interrupted : bool
fn interrupt(sig: i32) void {
    if(interrupted){
        os:exit(1)
    }
    interrupted = true
    // println("Interrupt - Stopping http servers...")
    os:exit(1)
}

