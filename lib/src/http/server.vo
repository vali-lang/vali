
header "sys" as sys;

use os;
use net;
use io;
use fs;
use mem;

class ServerData {
    socket: net:SocketTCP
    max_connections: uint
    thread_nr: uint (0)
    handler: fn(Request)(Response)
    static_dirs: Array[String] (Array[String].new())
    show_info: bool

    // fn _gc_transfer() {
    //     println("T.DATA")
    // }
    // fn _gc_free() {
    //     println("F.DATA")
    // }
}

shared server_fd : i32

fn test(req: Request) Response {
    return Response.html("Hello world!");
}

class Server {
    - host: String
    - port: u16
    - socket: net:SocketTCP
    - max_connections: uint
    - handler: fn(Request)(Response)
    // - static_dirs: Array[String] (Array[String].new())
    show_info: bool (false)

    fn _gc_transfer() {
        println("TRANSFER SERVER")
    }

    fn _gc_free() {
        println("FREEE HTTP SERVER")
    }

    static fn new(host: String, port: u16, handler: fn(Request)(Response)) Server !socket_init_error !socket_bind_error {

        let max_connections : uint = 10000;
        let socket = net:Socket.new_tcp(host, port, false) ! { throw socket_init_error }
        socket.bind() ! {
            throw socket_bind_error
        }
        server_fd = socket.fd;

        return Server{
            host: host,
            port: port,
            socket: socket,
            max_connections: max_connections,
            handler: handler,
        };
    }

    static fn server_data() ServerData !invalid_address {

        // let dirs = Array[String].new();
        // each this.static_dirs as dir {
        //     dirs.push(dir.copy());
        // }

        let host = "localhost"
        let port : u16 = 9000
        let socket = net:SocketTCP {
			host: host
			fd: server_fd
			port: port
			blocking: false
			addrinfo: net:SocketTCP.get_addrinfo(host, port) ! { throw invalid_address }
		}

        return ServerData {
            socket: socket
            max_connections: 10000
            handler: test
            show_info: true
        };
    }

    fn start(worker_count: i32 (16)) void {

        // SIGINT
        os:signal(1, interrupt);
        // SIGPIPE
        os:signal_ignore(13);

        if worker_count < 1 {
            worker_count = 1;
        }
        if worker_count > 128 {
            worker_count = 128;
        }

        if this.show_info {
            // println("[+] Running http server on port " + this.port.str());
            // println("[+] Worker count: " + worker_count.str());
        }

        print("start threads\n")
        worker_count--;
        while worker_count > 0 {
            // let copy = this.server_data();
            let thread = os:Thread.start(Server.worker)
            worker_count--;
            break
        }
        while true {
        os:sleep_ms(200);
        }

        // let copy = this.server_data();
        print("start main thread\n")
        Server.worker();
        os:sleep_ms(200);
        print("main thread stopped\n")
    }

    - static fn worker() void {

        let data = Server.server_data() ! {
            print("failed to get data\n")
            return
        }
        print("run work\n")

        let max_connections = data.max_connections;
        let handler = data.handler;

        // let nr = atomic(data.thread_nr + 1);

        //println("[-] Start thread: " + nr.str());

        let sock = data.socket;
        let sock_fd = sock.fd;

        let buf = mem:alloc(1000)

        let poll = io:Poll[?Connection].new();
        print("Socket fd: ")
        println(sock_fd.to_str())
        let sock_lsn = poll.create_listener(sock_fd, null);
        sock_lsn.detect_read_request(true);

        while true {
            let events = poll.wait();
            let event_count = events.length;
            let i : uint = 0;

            while i < event_count {
                let lsn_ = events.get(i) ! { break }
                if (@ptrv(lsn_, ptr) & 1) == 1 {
                    lsn_ = (@ptrv(lsn_, ptr) @as ptr - 1) @as io:Listener[?Connection]
                    lsn_.update_epoll()
                }
                let lsn = lsn_
                let fd = lsn.fd;
                i++;

                if fd == sock_fd {
                    // New connection
                    println("New connection")
                    let netcon = sock.accept() ! {
                        // print("failed to accept\n")
                        continue
                    }

                    let fd = netcon.fd;
                    if data.show_info {
                        // println("[+] New connection: " + fd.str());
                    }

                    let http_con = Connection {
                        netcon: netcon,
                        fd: fd,
                    };

                    let lsn = poll.create_listener(fd, http_con);
                    lsn.detect_read_request(true);
                    lsn.detect_write_request(false);
                    continue;
                }

                let http_con = lsn.data @as Connection
                if lsn.data == null {
                    print("❓ Missing http connection for fd: \n") // + lsn.fd.str());
                    net:Socket.close(lsn.fd);
                    continue;
                };

                if http_con.fd != fd {
                    print("❗ fd mismatch\n");
                    net:Socket.close(fd);
                    continue;
                }

                // Existing connection
                if lsn.has_stopped_the_connection() {
                    if data.show_info {
                        print("[+] Close connection: \n") // + fd.str());
                    }
                    net:Socket.close(fd);
                    continue;
                }

                if lsn.has_write_request() {
                    //println("[+] Continue sending response: " + fd.str());

                    if http_con.can_clear_out() {
                        http_con.reset_out();
                    }

                    http_con.send_response_bytes();

                    if http_con.has_data_to_send() == false {
                        lsn.detect_write_request(false);
                        http_con.reset_out();
                    }
                    continue;
                }
                if lsn.has_read_request() {
                    Server.respond(data, http_con, handler) ! {
                        if data.show_info {
                            // println("[+] Invalid request: " + fd.str());
                        }
                        net:Socket.close(fd)
                        continue
                    }
                    if http_con.has_data_to_send() {
                        lsn.detect_write_request(true)
                    } else {
                        http_con.reset_out()
                    }
                    continue;
                }
            }
        }
    }

    - static fn respond(data: ServerData, http_con: Connection, handler: fn(Request)(Response)) void !read_error !sent_error {

        // println("RESP")

        while true {
            let res = http_con.parse_result;
            let read_buf = http_con.read_buf;
            while true {
                if read_buf.start_index == read_buf.length {
                    // let bytes = http_con.netcon.recv(read_buf) ! |err| {
                    //     if err == err#e_again {
                    //         return;
                    //     }
                    //     http_con.respond(Response.error(400));
                    //     throw read_error, "Failed reading from connection";
                    // };
                    let bytes = http_con.netcon.recv(read_buf) ! {
                        return
                    }
                }
                Parser.parse_request(read_buf, res) ! {
                    http_con.respond(Response.error(400));
                    throw read_error //, "Invalid request";
                }

                read_buf.clear_before_start_index();

                if res.fully_parsed {
                    break
                }
            }

            if res.fully_parsed == false {
                return
            }

            http_con.reset_parser();

            // if data.static_dirs.length > 0 {
            //     let path = res.path.trim("/");
            //     each data.static_dirs as dir {
            //         let fullpath = dir + path; 
            //         if fs:is_file(fullpath) {
            //             let stream = fs:open(fullpath, true, false) !! continue;;
            //             http_con.send_file(stream, null);
            //             return;
            //         }
            //     }
            // }

            let req = Request{
                http_con: http_con,
			    headers: res.headers,
			    method: res.method,
			    body: res.body,
			    path: res.path,
            };
            let resp = handler(req);

            http_con.respond(resp);
        }
    }

    fn add_static_dir(path: String, relative_to_exe: bool (false)) void {
        // let full = path;
        // if relative_to_exe {
        //     full = fs:exe_dir() + "/" + path.trim("/");
        // }
        // full = full.rtrim("/") + "/";
        // if this.show_info {
        //     // println("[+] Add static dir: " + full);
        // }
        // this.static_dirs.push(full);
    }
}

global interrupted : bool;
fn interrupt(sig: i32) void {
    if(interrupted){
        os:exit(1);
    }
    interrupted = true;
    // println("Interrupt - Stopping http servers...");
    os:exit(1);
}

