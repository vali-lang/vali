
// use utils
// use io
// use mem

// // class ServerRequest {
// // 	method: String ("")
// // 	path: String ("")
// // 	headers: Map[String] (Map[String]{})
// // 	body: String ("")
// // }

// class ParseResult {
//     ~ status: uint (0)
//     // ~ header_sbuf: String (String.make_empty(2084))
//     ~ headers: Map[String] (Map[String]{})
//     ~ method: String ("")
//     ~ path: String ("")
//     ~ body: String ("")
//     ~ content_length: uint (0)
//     ~ headers_length: uint (0)
//     ~ has_parsed_headers: bool (false)
//     ~ has_parsed_body: bool (false)
//     - stage: uint (0)
//     - buffer: utils:ByteBuffer (utils:ByteBuffer.new(8192))
//     // - header_buffer: utils:ByteBuffer (utils:ByteBuffer.new(8192))
//     - parse_pos: uint (0)

//     fn clear() {
//         this.stage = 0
//         this.has_parsed_body = false
//         this.has_parsed_headers = false
//         this.content_length = 0
//         this.status = 0
//         this.body = ""
//         this.headers.clear()
//     }
//     fn clear_buffer() {
//         // this.header_buffer.clear()
//         this.buffer.clear()
//         this.parse_pos = 0
//     }
// }

// struct Parser {

//     // static fn parse_response(bytes: utils:ByteBuffer, result: ParseResult, only_headers: bool (false)) !invalid {
//     // 	Parser.parse_bytes(bytes, result, only_headers, false) ! { throw invalid }
//     // }
//     // static fn parse_request(bytes: utils:ByteBuffer, result: ParseResult, only_headers: bool (false)) !invalid {
//     //     Parser.parse_bytes(bytes, result, only_headers, true) ! { throw invalid }
//     // }

//     static fn parse_bytes(bytes: utils:ByteBuffer, result: ParseResult, only_headers: bool, is_request: bool) !invalid !http413 !already_parsed {

//         // Stage 0. Protocol & status
//         // Stage 1. Headers
//         // Stage 2. Body
//         // Stage 3. Done

//         if result.has_parsed_body {
//             result.clear()
//         }

//         let buffer = result.buffer
//         let pos = result.parse_pos

//         if pos == buffer.length {
//             result.clear_buffer()
//             pos = 0
//         }

//         buffer.append(bytes)

//         let stage = result.stage
//         let data = buffer.data
//         let length = buffer.length

//         // Header
//         if stage == 0 {
//             let index = buffer.index_of_byte('\r', pos) ! {
//                 if buffer.length - pos > 4096 {
//                     throw http413
//                 }
//                 return
//             }
//             if index + 1 == length { return }
//             if @ptrv(data, u8, index + 1) != '\n' { throw invalid }

//             let space1 = buffer.index_of_byte(' ', pos) ! { throw invalid }
//             let space2 = buffer.index_of_byte(' ', space1 + 1) ! { throw invalid }

//             if space1 > index { throw invalid }
//             if space2 > index { throw invalid }

//             if is_request {
//                 // Request "GET / HTTP/1.1"
//                 let method = buffer.sub_str(pos, space1)
//                 let path = buffer.sub_str(space1 + 1, space2 - space1 - 1)

//                 result.method = method;
//                 result.path = path;

//                 // let part3 = buffer.sub_str(space2 + 1, index - space2 - 1)
//                 // let version = part3;
//             } else {
//                 // Response "HTTP/1.1 200 OK"
//                 let part1 = buffer.sub_str(pos, space1)
//                 let part2 = buffer.sub_str(space1 + 1, space2 - space1 - 1)

//                 let version = part1;
//                 let status_str = part2;
//                 // result.status = status_str.to_uint() ! { throw invalid }
//             }

//             pos = index + 2;
//             result.parse_pos = pos;
//             stage = 1;
//             result.stage = stage;
//         }

//         // Headers
//         let headers = result.headers;
//         while stage == 1 {
//             let index = buffer.index_of_byte('\r', pos) ! {
//                 if buffer.length - pos > 4096 {
//                     throw http413
//                 }
//                 return
//             }
//             if index + 1 == length { return }
//             if @ptrv(data, u8, index + 1) != '\n' { throw invalid }

//             if index == pos {
//                 // End of headers
//                 pos = index + 2
//                 result.parse_pos = pos;
//                 stage = 2;
//                 result.stage = stage;
//                 result.has_parsed_headers = true
//                 break;
//             }

//             let split = buffer.index_of_byte(':', pos) ! { throw invalid }
//             if split > index { throw invalid }
//             while @ptrv(data, u8, split + 1) == ' ' {
//                 split++;
//             }

//             let key = bytes.sub_str(pos, split - pos - 1);
//             let value = bytes.sub_str(split + 1, index - split - 1);
//             headers.set(key.to_lower(), value);

//             // let key_len = split - pos - 1
//             // let value_len = index - split - 1
//             // if key_len > 2083 || value_len > 2083 : throw http413

//             // let hbuffer = result.header_buffer
//             // let headers_length = hbuffer.length + key_len + value_len + 2
//             // if headers_length > 8192 : throw http413

//             // let hbuf = result.header_sbuf
//             // mem:copy(buffer.data + pos, hbuf.data, key_len)
//             // @ptrv(hbuf.data, u8, key_len) = 0

//             // hbuf.modify_to_lower()
//             // if hbuf == "content-length" {
//             //     mem:copy(buffer.data + split + 1, hbuf.data, value_len)
//             //     @ptrv(hbuf.data, u8, value_len) = 0
//             //     let content_len = hbuf.to_uint() ! {
//             //         throw invalid;
//             //     }
//             //     result.content_length = content_len
//             // }

//             pos = index + 2
//             result.parse_pos = pos;
//         }

//         if only_headers {
//             return
//         }

//         if stage == 2 {
//             let content_len = result.content_length
//             let bytes_left = length - pos;
//             if bytes_left < content_len {
//                 return
//             }

//             let body = buffer.sub_str(pos, content_len);

//             pos += content_len;
//             result.has_parsed_body = true
//             result.body = body;
//             result.stage = 3;

//             result.parse_pos = pos;
//         }

//     }
// }
