
use utils
use io

// class ServerRequest {
// 	method: String ("")
// 	path: String ("")
// 	headers: Map[String] (Map[String]{})
// 	body: String ("")
// }

class ParseResult {
    ~ status: uint (0)
    ~ method: String ("")
    ~ path: String ("")
    ~ headers: Map[String] (Map[String]{})
    ~ body: String ("")
    ~ content_length: uint (0)
    ~ headers_length: uint (0)
    ~ has_parsed_headers: bool (false)
    ~ has_parsed_body: bool (false)
    - stage: uint (0)
    - buffer: utils:ByteBuffer (utils:ByteBuffer.new(8192))
    - parse_pos: uint (0)

    fn clear() {
        this.stage = 0
        this.has_parsed_body = false
        this.has_parsed_headers = false
        this.content_length = 0
        this.headers_length = 0
        this.status = 0
        this.body = ""
        this.headers.clear()
        this.buffer.clear()
        this.parse_pos = 0
    }
}

struct Parser {

    // static fn parse_response(bytes: utils:ByteBuffer, result: ParseResult, only_headers: bool (false)) !invalid {
    // 	Parser.parse_bytes(bytes, result, only_headers, false) ! { throw invalid }
    // }
    // static fn parse_request(bytes: utils:ByteBuffer, result: ParseResult, only_headers: bool (false)) !invalid {
    //     Parser.parse_bytes(bytes, result, only_headers, true) ! { throw invalid }
    // }

    static fn parse_bytes(bytes: utils:ByteBuffer, result: ParseResult, only_headers: bool, is_request: bool) !invalid !http413 !already_parsed {

        // Stage 0. Protocol & status
        // Stage 1. Headers
        // Stage 2. Body
        // Stage 3. Done

        if result.has_parsed_body {
            result.clear()
        }

        let buffer = result.buffer
        let pos = result.parse_pos

        buffer.append(bytes)

        let stage = result.stage
        let data = buffer.data
        let length = buffer.length

        // Header
        if stage == 0 {
            let index = buffer.index_of_byte('\r', pos) ! {
                if buffer.length - pos > 4096 {
                    throw http413
                }
                return
            }
            if index + 1 == length { return }
            if @ptrv(data, u8, index + 1) != '\n' { throw invalid }

            let space1 = buffer.index_of_byte(' ', pos) ! { throw invalid }
            let space2 = buffer.index_of_byte(' ', space1 + 1) ! { throw invalid }

            if space1 > index { throw invalid }
            if space2 > index { throw invalid }

            let part1 = buffer.sub_str(pos, space1);
            let part2 = buffer.sub_str(space1 + 1, space2 - space1 - 1);
            let part3 = buffer.sub_str(space2 + 1, index - space2 - 1);

            if is_request {
                // Request "GET / HTTP/1.1"
                result.method = part1;
                result.path = part2;
                let version = part3;
            } else {
                // Response "HTTP/1.1 200 OK"
                let version = part1;
                let status_str = part2;
                result.status = status_str.to_uint() ! { throw invalid }
            }

            pos = index + 2;
            result.parse_pos = pos;
            stage = 1;
            result.stage = stage;
        }

        // Headers
        let headers = result.headers;
        let content_len = result.content_length;
        while stage == 1 {
            let index = buffer.index_of_byte('\r', pos) ! {
                if buffer.length - pos > 4096 {
                    throw http413
                }
                return
            }
            if index + 1 == length { return }
            if @ptrv(data, u8, index + 1) != '\n' { throw invalid }

            if index == pos {
                // End of headers
                pos = index + 2;
                result.parse_pos = pos;
                stage = 2;
                result.stage = stage;

                let content_len_str = headers.get("content-length") ? "0";
                content_len = content_len_str.to_uint() ! {
                    throw invalid;
                };
                result.content_length = content_len
                result.has_parsed_headers = true
                break;
            }

            let split = buffer.index_of_byte(':', pos) ! { throw invalid }
            if split > index { throw invalid }
            while @ptrv(data, u8, split + 1) == ' ' {
                split++;
            }

            let key = buffer.sub_str(pos, split - pos - 1);
            let value = buffer.sub_str(split + 1, index - split - 1);
            headers.set(key.to_lower(), value);

            pos = index + 2;
            let headers_length = result.headers_length + (pos - result.parse_pos)
            result.parse_pos = pos;

            // Check max header length
            if headers_length > 8192 {
                throw http413
            }
            result.headers_length = headers_length
        }

        if only_headers {
            return
        }

        if stage == 2 {
            let bytes_left = length - pos;
            if bytes_left < content_len {
                return
            }

            let body = buffer.sub_str(pos, content_len);

            pos += content_len;
            result.has_parsed_body = true
            result.body = body;
            result.stage = 3;

            result.parse_pos = pos;
        }

    }
}
