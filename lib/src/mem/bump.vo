
value block_size (100000)

struct Bump {
    space_left: uint (0)
    start: ptr (null)
    current: ptr (null)
    adr: ptr (null)
    // Track
    space_added: uint (0)
    space_total: uint (0)
    space_total_last: uint (0)
    // Free list
    free_block: ptr (null)
    free_adr: ptr (null)
    free_space_left: uint (0)

    static fn contains_ptr(item: ptr) bool {
        let b = stack.bump
        let block = b.start
        while block != null {
            if item > block {
                if item < (block + block_size) {
                    return true
                }
            }
            block = @ptrv(block, ptr, 0)
        }
        return false
    }

    static fn new() Bump {
        let b = Bump {}
        b.create_block()
        b.start = b.current
        return b
    }
    fn create_block() {
        this.space_left = block_size - sizeof(ptr)
        let current = this.current
        if current != null {
            let next = @ptrv(current, ptr, 0)
            if next != null {
                this.current = next
                this.adr = next + sizeof(ptr)
                return
            }
        }
        let adr = alloc(block_size)
        if current != null {
            @ptrv(current, ptr, 0) = adr
        }
        @ptrv(adr, ptr, 0) = null
        this.current = adr
        this.adr = adr + sizeof(ptr)
        this.space_total += block_size
    }
    fn alloc(size: uint) ptr {
        let fsize = size + (size % sizeof(ptr))
        let left = this.space_left;
        if left < fsize {
            this.create_block()
        }
        let adr = this.adr
        this.space_left -= fsize
        this.adr = adr + fsize
        this.space_added += fsize
        return adr
    }

    fn wipe() {
        this.space_left = block_size - sizeof(ptr)
        let start = this.start
        this.current = start
        this.adr = start + sizeof(ptr)
        this.space_added = 0
    }

    fn delete() {
        let block = this.start
        while block != null {
            let next = @ptrv(block, ptr, 0)
            free(block)
            block = next
        }
        free(this @as ptr)
    }

    fn save_free_position() {
        this.free_block = this.current
        this.free_adr = this.adr
        this.free_space_left = this.space_left
    }
    fn add_free_item(item: ptr) {
        let fsize = sizeof(ptr) @as uint
        let left = this.space_left;
        if left < fsize {
            this.create_block()
        }
        let adr = this.adr;
        @ptrv(adr, ptr, 0) = item
        this.space_left -= fsize
        this.adr = adr + fsize
    }
    fn free_all_items() {
        this.current = this.free_block
        this.adr = this.free_adr
        this.space_left = this.free_space_left

        let block = this.current
        let adr = this.adr
        let space_left = this.space_left
        while block != null {
            while space_left >= sizeof(ptr) {
                let item = @ptrv(adr, ptr)
                if item == null {
                    block = null
                    break
                }
                // free(item)
                adr += sizeof(ptr)
                space_left -= sizeof(ptr)
            }
            if block == null {
                break
            }
            block = @ptrv(block, ptr, 0);
            adr = block + sizeof(ptr)
            space_left = block_size - sizeof(ptr)
        }

        this.current = this.free_block
        this.adr = this.free_adr
        this.space_left = this.free_space_left
    }
}
