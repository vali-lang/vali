
use mem
use os
use io

shared gc_manager_instance : @ignu(GcManager)
shared gc_age : u8

fn gc_manager() GcManager {
    let gc = gc_manager_instance
    while gc == null {
        gc = gc_manager_instance
    }
    return gc @as GcManager
}

struct GcManager {
    stacks : ptr
    stack_count : uint (0)
    free_index : uint(0)
    free_index_lock : uint (0)
    has_free_index : bool (false)
    stop : bool (false)
    stopped : bool (false)

    static fn init() {
        gc_age = 128
        if gc_manager_instance != null {
            return
        }
        gc_manager_instance = GcManager {
            stacks: mem:alloc(2000 * sizeof(ptr))
        }
        os:Thread.start_without_gc(GcManager.loop @as ptr)
    }

    fn add_stack(s: Stack) {
        let index = 0 @as uint
        let has_index = false
        if(this.has_free_index) {
            let lock = atomic(this.free_index_lock + 1)
            if lock == this.free_index {
                index = lock
                has_index = true
                atomic(this.free_index_lock - lock)
                this.has_free_index = false
            } else {
                atomic(this.free_index_lock - 1)
            }
        }
        if has_index == false {
            index = atomic(this.stack_count + 1)
        }
        @ptrv(this.stacks, Stack, index) = s
    }

    static fn loop() {
        let gm = gc_manager_instance;
        let cycles = 0
        let x = 0 @as uint;
        while true {
            x++

            //
            let sc = gm.stack_count;
            let up_to_date_count : uint = 0;
            let stacks = gm.stacks;
            let age = gc_age

            // Loop stacks
            let si = sc;
            while si > 0 {
                si--
                let s = @ptrv(stacks, Stack, si);
                if s @as ?Stack == null {
                    up_to_date_count++
                    if gm.has_free_index == false {
                        gm.free_index = si
                        atomic(gm.free_index_lock + si)
                        gm.has_free_index = true
                    }
                    continue;
                }
                if s.gc_age == age {
                    up_to_date_count++
                } else {
                    s.force_full = true
                }
                if s.stopped {
                    @ptrv(stacks, ?Stack, si) = null
                    free(s @as ptr)
                    continue
                }
            }

            // If all up-to-date
            if up_to_date_count == sc {
                gm.clean_unused()
                gc_age = (gc_age == 128) ? 64 @as u8 : 128 @as u8
            }

            //
            os:sleep_ms(500)
        }
    }

    fn clean_unused() {
        let age = gc_age
        // Mark shared globals
        #loop_globals as G, T
        #if @type_is_gc(T) && @global_is_shared(G)
        {
            let item = G @as ptr
            if item != null {
                if @ptrv(item, u8, byte_gc_age_rel) == 0 {
                    let vtable = @ptrv(item, u32, -1)
                    let table = @gc_get_vtable(vtable)
                    let func = @ptrv(table, fn(ptr, u8)(void), vt_mark_shared)
                    func(item, age);
                }
            }
        }
        #end
        #endloop

        // Clean
        let stacks = this.stacks
        let si = this.stack_count
        while si-- > 0 {
            let s = @ptrv(stacks, ?Stack, si)
            if isset(s) {
                s.clean_shared()
            }
        }
    }

    fn shutdown() {
        this.stop = true;
    }
}
