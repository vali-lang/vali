
use volt:mem
use volt:os

shared gc_instance : ?GC
shared gc : bool
shared gc_age : u8
shared gc_busy : uint
shared gc_object_count : uint

struct GC {
    stacks : ptr
    stack_count : int (0)

    static fn start() {
        gc_instance = GC {
            stacks: mem:alloc(10000)
        }
        os:Thread.start(GC.loop @as ptr)
    }

    fn add_stack(s: Stack) {
        let index = this.stack_count
        @ptrv(this.stacks, Stack, index) = s
        // todo atomic increment
        this.stack_count = index + 1
    }

    static fn loop() {
        let g = gc_instance;
        while 1 == 1 {
            let sc = g.stack_count;
            let stacks = g.stacks;
            // GC is running
            gc = true
            // Loop stacks
            let si = sc;
            while si-- > 0 {
                let s = @ptrv(stacks, Stack, si);
                if s.delete_me == false {
                    s.swap_chains()
                    s.mark();
                }
            }
            gc = false
            // Wait for other threads
            while gc_busy > 0 {
                os:sleep_ms(1);
            }
            // Delete unmarked objects
            si = sc;
            while si-- > 0 {
                let s = @ptrv(stacks, Stack, si);
                // if s.delete_me && s.object_count == 0 {
                //     // TODO
                //     print("Delete stack (TODO)\n")
                // } else {
                    s.delete_unmarked();
                // }
            }
            // Increase age
            gc_age++
            // Wait but make sure memory doesnt increase too much
            let count = gc_object_count
            let comp = 100 + count + count / 90
            let x = 1000 // Max 1 second
            while x-- > 0 {
                os:sleep_ms(1);
                if gc_object_count > comp {
                    break
                }
            }
        }
    }
}
