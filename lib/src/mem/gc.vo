
use volt:mem
use volt:os

shared gc_instance : ?Gc
shared gc_age : u8
shared gc_busy : uint
shared gc_object_count : int

// item :
// state(u8)    0 new 1 unknown 2 solid
// in_list(u8)  0 new 1 unknown 2 none 3 transfer
// fields(u8)

struct Gc {
    stacks : ptr
    stack_count : int (0)

    static fn start() {
        gc_instance = Gc {
            stacks: mem:alloc(10000)
        }
        os:Thread.start(Gc.loop @as ptr)
    }

    fn add_stack(s: Stack) {
        let index = this.stack_count
        @ptrv(this.stacks, Stack, index) = s
        atomic(this.stack_count + 1)
    }

    static fn loop() {
        let g = gc_instance;
        let cycles = 0
        let last_age = gc_age
        let x = 0;
        while true {
            x++
            let sc = g.stack_count;
            let stacks = g.stacks;
            // Loop stacks
            let si = sc;
            while si > 0 {
                si--
                let s = @ptrv(stacks, Stack, si);
                if x < 20 {
                    s.lowest = s.lowest_next 
                    s.lowest_next = s.stack_adr + (100000 * sizeof(ptr)) // Add 100k
                }
                if x % 20 == 0 {
                    s.lowest = s.lowest_next 
                    s.lowest_next = s.stack_adr + (100000 * sizeof(ptr)) // Add 100k
                }
                //
                if s.run_gc_timeout > 0 {
                    s.run_gc_timeout--
                }
                let full_tm = s.run_gc_full_timeout
                if full_tm > 0 {
                    s.run_gc_full_timeout--
                    if full_tm == 1 {
                        s.run_gc_timeout = 0
                    }
                }
            }
            os:sleep_ms(10)
        }
    }
}
