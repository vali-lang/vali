
use mem

struct GcRing[T] {
    - data: ptr
    - size: uint
    ~ length: uint (0)
    - index: uint (0)

    static fn new() CLASS {
        let size : uint = 4;
        return CLASS {
            data: mem:alloc(size * sizeof(T))
            size: size
        }
    }

    fn add(item: T) {
        let length = this.length
        let data = this.data

        let index = this.index
        @ptrv(data, T, index) = @gc_link(this, item)
        let new_len = length + 1
        this.length = new_len

        if new_len == this.size {
            data = this.increase_size()
        }

        let new_index = index + 1
        if new_index == this.size {
            new_index = 0
        } 
        this.index = new_index
    }

    fn remove(index: uint) {
        let len = this.length
        if len == 0 : return
        let ci = this.index
        let last = ci - len
        if len > ci {
            last = this.size - len + ci
        }
        if last != index {
            let data = this.data
            @ptrv(data, T, index) = @ptrv(data, T, last)
        }
        this.length = len - 1
    }

    fn last_index() uint {
        let len = this.length
        let ci = this.index
        let last = ci - len
        if len > ci {
            last = this.size - len + ci
        }
        return last
    }

    fn increase_size() ptr {
        let data = this.data
        let size = this.size
        let new_size = size * 2
        let new_data : ptr = null
        new_data = mem:alloc(new_size * sizeof(T));
        mem:copy(data, new_data, size * sizeof(T));
        mem:free(data)
        this.data = new_data
        this.size = new_size
        return new_data
    }
}