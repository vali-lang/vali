
global pool_8 : @ignu(GcPool)
global pool_16 : @ignu(GcPool)
global pool_24 : @ignu(GcPool)
global pool_32 : @ignu(GcPool)
global pool_40 : @ignu(GcPool)
global pool_48 : @ignu(GcPool)
global pool_56 : @ignu(GcPool)
global pool_64 : @ignu(GcPool)
global pool_128 : @ignu(GcPool)
global pool_256 : @ignu(GcPool)

global pool_usage : uint

use io
use os

struct GcPool {
    size: uint
    first : ptr
    current : ptr
    index : uint (0)
    items_used: uint (0)
    items_total: uint
    items_total_last: uint

    static fn init() {
        pool_8 = CLASS.new(8)
        pool_16 = CLASS.new(16)
        pool_24 = CLASS.new(24)
        pool_32 = CLASS.new(32)
        pool_40 = CLASS.new(40)
        pool_48 = CLASS.new(48)
        pool_56 = CLASS.new(56)
        pool_64 = CLASS.new(64)
        pool_128 = CLASS.new(128)
        pool_256 = CLASS.new(256)
    }
    static fn new(size_: uint) CLASS {
        let size = size_ + 8
        let block = GcPool.create_block(size, 2)
        let pool = CLASS{
            size: size
            first: block
            current: block
            items_total: @ptrv(block, uint, 1)
            items_total_last: @ptrv(block, uint, 1)
        }
        return pool
    }

    // ptr next, ptr itemc, ptr transferc, {...items...}
    static fn create_block(size: uint, itemc: uint) ptr {
        if itemc > 250 {
            itemc = 250
        }
        let fsize = itemc * size + 3 * sizeof(ptr)
        let block = alloc(fsize)
        clear(block, fsize)
        @ptrv(block, uint, 1) = itemc
        return block
    }

    fn get_next_block_or_create(current: ptr) ptr {

        let next = @ptrv(current, ptr)
        if next == null {
            next = GcPool.create_block(this.size, this.items_total * 2)
            this.items_total += @ptrv(next, uint, 1)
            @ptrv(current, ptr) = next
        }

        let usage = this.items_used * 100 / this.items_total_last

        if usage > pool_usage {
            pool_usage = usage
            if usage > 80 {
                stack.run_gc = true
                stack.bumper_overflow = true
            }
        }

        return next
    }

    fn get(vtable: u32) ptr {
        let block = this.current
        let index = this.index
        let itemc = @ptrv(block, uint, 1) // Item count
        let tc = @ptrv(block, uint, 2) // Transfer count
        while tc > itemc * 7 / 10 {
            block = this.get_next_block_or_create(block)
            index = 0
            itemc = @ptrv(block, uint, 1)
            tc = @ptrv(block, uint, 2)
            this.current = block
        } 
        //
        let base = block + sizeof(ptr) * 3
        let item = base + (this.size * index)
        while @ptrv(item, u8) != 0 {
            index++
            if index == itemc {

                block = this.get_next_block_or_create(block)
                index = 0
                base = block + sizeof(ptr) * 3
                itemc = @ptrv(block, uint, 1)
                this.current = block

                let tc = @ptrv(block, uint, 2)
                while tc > itemc * 7 / 10 {
                    block = this.get_next_block_or_create(block)
                    index = 0
                    itemc = @ptrv(block, uint, 1)
                    tc = @ptrv(block, uint, 2)
                    this.current = block
                    base = block + sizeof(ptr) * 3
                } 
            }
            item = base + (this.size * index)
        }
        let res = item
        let new_index = index + 1
        this.index = new_index
        if new_index == itemc {
            this.current = this.get_next_block_or_create(block)
            this.index = 0
        }
        @ptrv(res, u16, 0) = 0
        @ptrv(res, u8, 2) = 0
        @ptrv(res, u8, 3) = index @as u8
        @ptrv(res, u32, 1) = vtable

        this.items_used++

        return res + 8
    }

    static fn reset_all() {
        pool_8.reset()
        pool_16.reset()
        pool_24.reset()
        pool_32.reset()
        pool_40.reset()
        pool_48.reset()
        pool_56.reset()
        pool_64.reset()
        pool_128.reset()
        pool_256.reset()
    }
    fn reset() {
        // Clear all un-used blocks after current
        let block = this.current
        let prev = block
        let next = @ptrv(block, ptr)
        while next != null {
            let block = next
            next = @ptrv(block, ptr)
            if @ptrv(block, uint, 2) == 0 {
                // Delete block
                this.items_total -= @ptrv(block, uint, 1)
                free(block)
                @ptrv(prev, ptr) = next
            } else {
                // Keep block
                prev = block
            }
        }

        // Set current to first
        this.current = this.first
        this.index = 0
        this.items_used = 0
        this.items_total_last = this.items_total
        pool_usage = 0
    }

    static fn clean_old_all(age: u8) {
        pool_8.clean_old_age(age)
        pool_16.clean_old_age(age)
        pool_24.clean_old_age(age)
        pool_32.clean_old_age(age)
        pool_40.clean_old_age(age)
        pool_48.clean_old_age(age)
        pool_56.clean_old_age(age)
        pool_64.clean_old_age(age)
        pool_128.clean_old_age(age)
        pool_256.clean_old_age(age)
    }
    fn clean_old_age(age: u8) {
        let block = this.first
        let size = this.size
        while block != null {
            let b = block
            let itemc = @ptrv(b, uint, 1)
            let base = b + sizeof(ptr) * 3
            let removed_count : uint = 0 
            while itemc-- > 0 {
                let item = base + (size * itemc)
                let state = @ptrv(item, u8, 0)
                if state != state_solid {
                    continue
                }
                if @ptrv(item, u8, 2) != age {
                    let vtable = @ptrv(item, u32, 1)
                    let table = @gc_get_vtable(vtable)
                    let func = @ptrv(table, ?fn(ptr)(void), 2)
                    if func != null {
                        func(item);
                    }
                    @ptrv(item, u8, 0) = 0 // reset state
                    removed_count++
                }
            }
            // Adjust transfer count
            @ptrv(b, uint, 2) -= removed_count
            // Next block
            block = @ptrv(b, ptr)
        }
    }

    static fn delete_all() {
        pool_8.delete()
        pool_16.delete()
        pool_24.delete()
        pool_32.delete()
        pool_40.delete()
        pool_48.delete()
        pool_56.delete()
        pool_64.delete()
        pool_128.delete()
        pool_256.delete()
    }
    fn delete() {
        let block = this.first
        while block != null {
            let next = @ptrv(block, ptr)
            free(block)
            block = next
        }

        free(this)
    }
}

