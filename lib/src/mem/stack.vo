
use volt:mem
use volt:os

global stack : ?Stack;
global allocator : ?Bump;

value state_new (0)
value state_transfer (2)
value state_solid (4)
value state_unknown (6)
value state_freed (8)
value state_freed2 (10)
value state_global (12)
value state_const (14)
value stack_size (1000000)

value sub_state_keep (5)
value sub_state_unknown (6)
value sub_state_on_stack (7)

value byte_moved (0)
value byte_state (0)
value byte_sub_state (1)
value byte_fields (2)
value byte_in_move_check_list (3)
// size : i32

value trigger_lowest (0)
value trigger_buffer_size (1)
value trigger_gc_count (2)

struct Stack {
    stack_base : ptr
    stack_adr : ptr
    stack_adr_last : ptr

    space_transfered: uint (0)
    space_min : uint (1000)
    space_max : uint (100000)

    lowest: ptr
    lowest_next : ptr
    gc_count: uint (0)
    gc_trigger: uint (1000)

    unknown : ObjectChain
    transfer : ObjectChain
    move_checks : ObjectChain

    bump: Bump

    age: u8 (33)
    force_full: bool (false)
    stopped: bool (false)

    static fn init() {
        let unknown = ObjectChain.new()
        let transfer = ObjectChain.new()
        let move_checks = ObjectChain.new()
        let bump = Bump.new()

        let data = alloc(stack_size)
        let stackc = stack_size / sizeof(ptr)
        while stackc > 0 {
            stackc--
            @ptrv(data, ptr, stackc) = null
        }

        let s = Stack {
            stack_base: data
            stack_adr: data
            stack_adr_last: data

            lowest: data
            lowest_next: data + (100 * sizeof(ptr))

            unknown: unknown
            transfer: transfer
            move_checks: move_checks
            bump: bump
        }

        allocator = bump
        stack = s;

        let gcm = gc_manager()
        gcm.add_stack(s);
    }

    ///////////////////////
    // Runtime functions
    ///////////////////////
    static fn link(on: ptr, to: ptr) ptr {
        let to_state = @ptrv(to, u8, 0)
        let on_state = @ptrv(on, u8, 0)
        if on_state == state_global {
            // TODO move item to global
            print("TODO: MOVE TO GLOBAL")
            return to
        }
        if to_state == state_new {
            // Transfer
            stack.transfer.add_item(to)
            @ptrv(to, u8, 0) = state_transfer
            @ptrv(to, u8, 1) = state_unknown
        }
        if on_state == state_solid {
            // Update transfer state (if solid)
            @ptrv(to, u8, 1) = state_solid
        }
        // Add to move check list
        let in_list = @ptrv(on, u8, 3)
        if in_list == 0 {
            stack.move_checks.add_item(on)
            @ptrv(on, u8, 3) = 1
        }
        return to
    }
    static fn unlink(item: ptr) {
        let item_state = @ptrv(item, u8, 0)
        if item_state == state_solid {
            stack.unknown.add_item(item)
            @ptrv(item, u8, 0) = state_unknown
            @ptrv(item, u8, 1) = 0
        } else if item_state == state_transfer {
            // Update transfer state
            @ptrv(item, u8, 1) = state_unknown
        }
    }

    ///////////////////////
    // Gc
    ///////////////////////
    fn gc(trigger_type: u8) {

        let gc_trigger = this.gc_trigger;
        let gc_count = this.gc_count;
        if trigger_type == trigger_gc_count {
            // Cannot find lowest point, reset lowest
            this.lowest = this.lowest_next
            this.lowest_next = this.stack_adr + (100000 * sizeof(ptr))
            // Increase trigger count
            gc_trigger = gc_trigger * 100
            if gc_trigger > 4000000 {
                gc_trigger = 4000000
            }
            this.gc_count = 0;
            this.gc_trigger = gc_trigger;
            return
        }

        this.mark_difference_down()
        this.handle_transfer_list()
        this.check_moves()
        this.bump.wipe()

        // Full clear
        let unknown_count = this.unknown.itemc
        if this.force_full {
            unknown_count = 1
        }
        if this.lowest_next < this.lowest {
            // When reaching a new low, do a full clear
            unknown_count = 1
            this.lowest = this.lowest_next
        }
        if unknown_count > 0 {
            this.clean_unknown_list()
            this.force_full = false
        }

        // Lowest stack point
        if trigger_type == trigger_lowest {
            gc_trigger = gc_trigger / 99 * 100
            if gc_trigger < 10000 {
                gc_trigger = 10000
            }
        } else if trigger_type == trigger_buffer_size {
            // Increase lowest point
            this.lowest = this.lowest_next
            this.lowest_next = this.stack_adr + (100000 * sizeof(ptr))
            // Reduce trigger count
            gc_trigger = gc_trigger / 100
            if gc_trigger < 1000 {
                gc_trigger = 1000
            }
        }

        this.space_max = this.bump.space_total * 12 / 10
        this.space_min = this.bump.space_total >> 2

        this.space_transfered = 0
        this.stack_adr_last = this.stack_adr
        this.gc_count = 0
        this.gc_trigger = gc_trigger
    }

    fn mark_difference_down() {
        let transfer = this.transfer
        let unknown = this.unknown

        let stack_base = this.stack_base
        let stack_adr = this.stack_adr
        let adr_last = this.stack_adr_last

        // Mark previous items as: not on stack
        let adr = adr_last;
        while adr > stack_base {
            let item_adr = adr - sizeof(ptr) * 2
            adr = item_adr
            let item_prev = @ptrv(item_adr, ptr, 1);
            if item_prev != null {
                @ptrv(item_prev, u8, byte_sub_state) = 0
            }
        }

        // Mark items as: on stack
        // Mark new items as transfer
        adr = stack_adr;
        while adr > stack_base {
            let item_adr = adr - sizeof(ptr) * 2
            adr = item_adr
            let item = @ptrv(item_adr, ptr, 0);
            if item != null {
                //
                let state = @ptrv(item, u8, 0)
                if state == state_new {
                    // Transfer new items
                    transfer.add_item(item)
                    @ptrv(item, u8, 0) = state_transfer @as u8
                    @ptrv(item, u8, 1) = state_solid @as u8
                    continue;
                } 
                if state == state_transfer {
                    @ptrv(item, u8, 1) = state_solid @as u8
                    continue;
                } 

                @ptrv(item, u8, 1) = sub_state_on_stack
            }
        }

        // Previous items that are not on stack: add them to unknown
        // Set previous to null
        adr = adr_last;
        while adr > stack_base {
            let item_adr = adr - sizeof(ptr) * 2
            adr = item_adr
            let item_prev = @ptrv(item_adr, ptr, 1);
            if item_prev != null {
                if @ptrv(item_prev, u8, byte_sub_state) != sub_state_on_stack {
                    if @ptrv(item_prev, u8, 0) == state_solid {
                        unknown.add_item(item_prev)
                        @ptrv(item_prev, u8, 0) = state_unknown @as u8
                    }
                }
                // Clear previous
                @ptrv(item_adr, ptr, 1) = null
            }
        }

        // Set previous to current
        adr = stack_adr;
        while adr > stack_base {
            let item_adr = adr - sizeof(ptr) * 2
            adr = item_adr
            @ptrv(item_adr, ptr, 1) = @ptrv(item_adr, ptr, 0)
        }
    }

    fn handle_transfer_list() {
        let chain = this.transfer
        let last_list = chain.olist_last
        let last_index = chain.index
        let first_list = chain.olist_first
        let next_list = first_list

        let count : uint = 0 @as uint
        let counter = @ptr_of(count)

        // Mark solid
        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = chain_size
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if (@ptrv(item, u8, byte_moved) & 1) == 1 {
                    continue
                }
                if @ptrv(item, u8, 0) != state_transfer {
                    continue
                }
                if @ptrv(item, u8, 1) != state_solid {
                    continue
                }
                Stack.transfer_to_solid_rec(item, counter)
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, chain_size)
            if next_list == null {
                break
            }
        }

        // Mark unknown
        next_list = first_list
        let unknown = this.unknown
        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = chain_size
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if (@ptrv(item, u8, byte_moved) & 1) == 1 {
                    continue
                }
                if @ptrv(item, u8, 0) != state_transfer {
                    continue
                }
                if @ptrv(item, u8, 1) != state_unknown {
                    continue
                }
                Stack.transfer_to_unknown_rec(item, unknown, counter)
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, chain_size)
            if next_list == null {
                break
            }
        }

        chain.wipe()

        this.space_transfered = count
    }

    fn clean_unknown_list() {
        // Update age
        let new_age = 64 @as u8
        if this.age == 64 {
            new_age = 66
        }
        let age = this.age + 1
        this.age = age

        //
        this.mark_stack_as_solid()

        let bump = this.bump
        bump.save_free_position()

        let chain = this.unknown
        let last_list = chain.olist_last
        let last_index = chain.index
        let next_list = chain.olist_first

        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = chain_size
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if @ptrv(item, u8, 0) > state_unknown {
                    // Ignore freed, globals, consts
                    continue;
                }
                if @ptrv(item, u8, 1) != age {
                    // Free item + all sub items with incorrect age and have solid state
                    Stack.free_rec(item, age, bump)
                }
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, chain_size)
        }

        chain.wipe()

        bump.add_free_item(null)
        bump.free_all_items()
    }

    static fn free_rec(item: ptr, age: u8, bump: Bump) {
        bump.add_free_item(item)
        @ptrv(item, u8, 0) = state_freed

        let fields = @ptrv(item, u8, 2)
        while fields > 0 {
            let field = fields--
            let sub = @ptrv(item, ptr, field)
            if sub != null {
                let sub_state = @ptrv(sub, u8, 0)
                if sub_state < state_freed {
                    if @ptrv(sub, u8, 1) != age {
                        Stack.free_rec(sub, age, bump)
                        continue;
                    }
                }
            }
        }
    }

    fn mark_stack_as_solid() {
        let item_adr = this.stack_base
        let stack_adr = this.stack_adr
        let age = this.age
        while item_adr < stack_adr {
            let item = @ptrv(item_adr, ptr);
            if item != null {
                if @ptrv(item, u8, 0) < state_freed {
                    if @ptrv(item, u8, 1) != age {
                        Stack.mark_stack_item_as_solid_rec(item, age)
                    }
                }
            }
            item_adr = item_adr + sizeof(ptr) * 2
        }
    }
    static fn mark_stack_item_as_solid_rec(item: ptr, age: u8) {
        @ptrv(item, u8, 1) = age

        let fields = @ptrv(item, u8, 2)
        while fields > 0 {
            let field = fields--
            let sub = @ptrv(item, ptr, field)
            if sub != null {
                if @ptrv(sub, u8, 0) < state_freed {
                    if @ptrv(sub, u8, 1) != age {
                        Stack.mark_stack_item_as_solid_rec(sub, age)
                    }
                }
            }
        }
    }

    fn check_moves() {
        let chain = this.move_checks
        let last_list = chain.olist_last
        let last_index = chain.index
        let next_list = chain.olist_first

        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = chain_size
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Remove checkmark
                @ptrv(item, u8, 3) = 0
                // Item logic
                let fields = @ptrv(item, u8, 2)
                while fields > 0 {
                    let field = fields--
                    let sub = @ptrv(item, ptr, field)
                    if sub != null {
                        let is_moved = (@ptrv(sub, u8, byte_moved) & 1) == 1
                        if is_moved {
                            // Adjust field
                            @ptrv(item, ptr, field) = @ptrv(sub, ptr, 0) - 1
                        }
                    }
                }

            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, chain_size)
        }

        chain.wipe()

        // Check stack objects that have been moved
        let data = this.stack_base
        let adr = this.stack_adr
        while adr > data {
            let item_adr = adr - sizeof(ptr) * 2
            adr = item_adr
            let item = @ptrv(item_adr, ptr);
            if item == null {
                continue
            }
            if (@ptrv(item, u8, byte_moved) & 1) == 1 {
                // Object was moved
                let new_item = @ptrv(item, ptr, 0) - 1

                @ptrv(item_adr, ptr) = new_item
                @ptrv(item_adr, ptr, 1) = new_item
            }
        }
    }

    static fn transfer_to_solid_rec(item: ptr, counter: ptr) ptr {
        // 
        let size = @ptrv(item, i32, 1) @as uint
        let new_item = alloc(size)
        copy(item, new_item, size)
        @ptrv(item, ptr, 0) = new_item | 1
        @ptrv(new_item, u8, 0) = state_solid @as u8

        @ptrv(counter, uint) += size

        let fields = @ptrv(new_item, u8, 2)
        while fields > 0 {
            let field = fields--
            let sub = @ptrv(item, ptr, field)
            if sub != null {
                if (@ptrv(sub, u8, byte_moved) & 1) == 1 {
                    // Already moved
                    @ptrv(new_item, ptr, field) = @ptrv(sub, ptr, 0) - 1
                    continue
                }
                if @ptrv(sub, u8, 0) < state_solid {
                    // transfer or new
                    @ptrv(new_item, ptr, field) = Stack.transfer_to_solid_rec(sub, counter)
                }
            }
        }
        return new_item
    }
    static fn transfer_to_unknown_rec(item: ptr, unknown: ObjectChain, counter: ptr) ptr {
        // 
        let size = @ptrv(item, i32, 1) @as uint
        let new_item = alloc(size)
        copy(item, new_item, size)
        @ptrv(item, ptr, 0) = new_item | 1
        @ptrv(new_item, u8, 0) = state_unknown @as u8
        unknown.add_item(new_item)

        @ptrv(counter, uint) += size

        let fields = @ptrv(new_item, u8, 2)
        while fields > 0 {
            let field = fields--
            let sub = @ptrv(item, ptr, field)
            if sub != null {
                if (@ptrv(sub, u8, byte_moved) & 1) == 1 {
                    // Already moved
                    @ptrv(new_item, ptr, field) = @ptrv(sub, ptr, 0) - 1
                    continue
                }
                if @ptrv(sub, u8, 0) < state_solid {
                    // transfer or new
                    @ptrv(new_item, ptr, field) = Stack.transfer_to_unknown_rec(sub, unknown, counter)
                }
            }
        }
        return new_item
    }

    fn stop() {
        //
        this.force_full = true
        this.stack_adr = this.stack_base
        this.gc(trigger_lowest)
        //
        this.transfer.delete()
        this.move_checks.delete()

        // Clear bump allocator
        let bump = this.bump
        bump.save_free_position()

        // Clear unknown list
        let chain = this.unknown
        let last_list = chain.olist_last
        let last_index = chain.index
        let next_list = chain.olist_first

        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = chain_size
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if @ptrv(item, u8, 0) == state_unknown {
                    Stack.free_item_rec(item, bump)
                }
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, chain_size)
        }

        chain.delete()

        // Clear stack
        let data = this.stack_base
        let adr = this.stack_adr
        while adr > data {
            let item_adr = adr - sizeof(ptr) * 2
            adr = item_adr
            let item = @ptrv(item_adr, ptr);
            let item_prev = @ptrv(item_adr, ptr, 1);

            if @ptrv(item, u8, 0) == state_solid {
                Stack.free_item_rec(item, bump)
            } else if @ptrv(item, u8, 0) == state_unknown {
                Stack.free_item_rec(item, bump)
            }
            if @ptrv(item_prev, u8, 0) == state_solid {
                Stack.free_item_rec(item_prev, bump)
            } else if @ptrv(item_prev, u8, 0) == state_unknown {
                Stack.free_item_rec(item_prev, bump)
            }
        }

        // Free all items
        bump.add_free_item(null)
        bump.free_all_items()
        bump.delete()

        // Stack is deleted by the Gc
        this.stopped = true
    }

    static fn free_item_rec(item: ptr, bump: Bump) {
        @ptrv(item, u8, 0) = state_freed2
        bump.add_free_item(item)

        let fields = @ptrv(item, u8, 2)
        while fields > 0 {
            let field = fields--
            let sub = @ptrv(item, ptr, field)
            if sub != null {
                if @ptrv(sub, u8, 0) == state_solid {
                    Stack.free_item_rec(sub, bump)
                } else if @ptrv(sub, u8, 0) == state_unknown {
                    Stack.free_item_rec(sub, bump)
                }
            }
        }
    }

}

