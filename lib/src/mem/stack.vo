
use volt:mem

global stack : ?Stack;

struct Stack {
    data : ptr
    count : int (0)
    delete : bool (false)
    olist_first : ptr
    olist_last : ptr
    olist_index : int (0)
    delete_index : int (0)

    static fn new() Stack {
        let list = Stack.new_olist()
        let s = Stack {
            data: mem:alloc(100000)
            olist_first: list
            olist_last: list
        }
        (gc_instance @as GC).add_stack(s);
        return s
    }

    static fn create_thread_stack() {
        let s = Stack.new()
        stack = s;
    }

    ///////////////////////
    // Stack items
    ///////////////////////
    fn reserve(amount: int) ptr {
        let count = this.count
        let adr = this.data + (count * sizeof(ptr) * 2);
        let x = amount * 2
        while x > 0 {
            @ptrv(adr, ptr, --x) = 0 @as ptr;
            @ptrv(adr, ptr, --x) = 0 @as ptr;
        }
        this.count += count
        return adr
    }
    fn pop(amount: int) {
        this.count -= amount;
    }

    fn mark() {
        let data = this.data
        let x = this.count * 2
        while x > 0 {
            let item = @ptrv(data, ptr, --x);
            let handler = @ptrv(data, ptr, --x);
        }
    }

    ///////////////////////
    // Allocated items
    ///////////////////////
    fn add_gc_object(item: ptr, handler: ptr) {
        let index_ = this.olist_index;
        if index_ == 200 {
            let new_list = Stack.new_olist()
            @ptrv(this.olist_last, ptr, index_) = new_list
            this.olist_last = new_list
            this.olist_index = 0
        }
        let index = this.olist_index
        let list = this.olist_last
        @ptrv(list, ptr, index) = item
        @ptrv(list, ptr, index + 1) = handler
        this.olist_index = index + 2
    }

    fn delete_unmarked() {
    }

    static fn new_olist() ptr {
        return mem:alloc(101 * sizeof(ptr) * 2)
    }
}

// x.prop = something
// if(gc == 1 && something.age != gc_age) {
//   something.update_age_recursive();
// }

// ---------

// fn update_age_recursive() {
//    atomic(gc_busy + 1)
//    this.mark_gc();
//    atomic(gc_busy - 1)
// }

// fn mark_gc() {
//    let age = atomic(this.age + 1);
//    if age != gc_age { atomic(this.age - 1); return }
   
//    // go over each prop
//    let prop = this.{prop-name}
//    if prop.age != age { prop.mark_gc(); }
// }
