
use volt:mem
use volt:os

global stack : ?Stack;

value state_new (0)
value state_transfer (1)
value state_solid (2)
value state_unknown (3)

struct Stack {
    data : ptr
    count : uint (0)
    object_count : uint (0)
    object_count_last : uint (0)
    lowest: uint (0)
    lowest_next : uint (0)
    unknown : ObjectChain
    transfer : ObjectChain
    newbs : ObjectChain
    move_checks : ObjectChain
    allow_gc : bool (false)
    bump: Bump

    static fn new() Stack {
        let unknown = ObjectChain.new()
        let transfer = ObjectChain.new()
        let newbs = ObjectChain.new()
        let move_checks = ObjectChain.new()
        let bump = Bump.new()

        let s = Stack {
            data: mem:alloc(100000)
            unknown: unknown
            transfer: transfer
            newbs: newbs
            move_checks: move_checks
            bump: bump
        }
        (gc_instance @as GC).add_stack(s);
        return s
    }

    static fn create_thread_stack() {
        let s = Stack.new()
        stack = s;
    }

    ///////////////////////
    // Stack items
    ///////////////////////
    fn reserve(amount: uint) ptr {
        let count = this.count
        let adr = this.data + (count * sizeof(ptr) * 2);
        this.count = count + amount
        return adr
    }
    fn pop(amount: uint) {
        let data = this.data;
        let count = this.count
        let new_count = count - amount
        if new_count < this.lowest_next {
            this.lowest_next = new_count
        }
        this.count = new_count;
        // if new_count == 0 {
            // print("stack_empty\n");
        // }
    }

    ///////////////////////
    // Allocate items
    ///////////////////////
    fn add_gc_object(item: ptr) {
        this.newbs.add_item(item)
        // atomic(gc_object_count + 1)
        this.object_count++
    }

    ///////////////////////
    // Runtime functions
    ///////////////////////
    static fn gc_check() {
        let s = stack
        if s.allow_gc == false {
            if s.object_count < s.object_count_last * 2 {
                if s.count > s.lowest {
                    return
                }
            }
        }
        // print("gc\n")
        s.gc()
        s.allow_gc = false
        s.object_count_last = s.object_count
    }
    static fn link(on: ptr, to: ptr) ptr {
        if to == 0 @as ptr {
            return to
        }
        let on_state = @ptrv(on, u8, 0)
        if on_state > state_transfer {
            let to_state = @ptrv(to, u8, 0)
            if to_state == state_new {
                // Transfer
                stack.transfer.add_item(to)
                @ptrv(to, u8, 0) = state_transfer @as u8
                @ptrv(to, u8, 1) = on_state @as u8
            } else if on_state == state_solid {
                // Update transfer state (if solid)
                @ptrv(to, u8, 1) = state_solid @as u8
            }
        }
        return to
    }
    static fn unlink(item: ptr) {
        if item == (0 @as ptr) {
            return
        }
        let item_state = @ptrv(item, u8, 0)
        if item_state == state_solid {
            stack.unknown.add_item(item)
            @ptrv(item, u8, 1) = state_unknown @as u8
        } else if item_state == state_transfer {
            // Update transfer state
            @ptrv(item, u8, 1) = state_unknown @as u8
        }
    }

    ///////////////////////
    // Gc
    ///////////////////////
    fn gc() {
        let do_full_clear = false
        this.mark_difference_down()
        // Fast clear
        if do_full_clear == false {
            this.handle_transfer_list()
            this.clean_new_list()
            return
        }
        // Full clear
    }

    fn mark_difference_down() {
        let data = this.data
        let x = this.count
        let transfer = this.transfer
        let unknown = this.unknown
        while x > 0 {
            x--
            let index = x * 2
            let item = @ptrv(data, ptr, index);
            let item_prev = @ptrv(data, ptr, index + 1);
            if item != item_prev {
                // Stack position changed
                if item_prev != 0 @as ptr {
                    // Mark prev as unknown
                    if @ptrv(item, u8, 0) == state_solid {
                        unknown.add_item(item)
                        @ptrv(item, u8, 0) = state_unknown @as u8
                    }
                }
                if item != 0 @as ptr {
                    // Substate = solid
                    @ptrv(item, u8, 1) = state_solid @as u8
                    // Check if transfer needed
                    if @ptrv(item, u8, 0) == state_new {
                        transfer.add_item(item)
                        @ptrv(item, u8, 0) = state_transfer @as u8
                    } 
                }
                // Overwrite prev
                @ptrv(data, ptr, index + 1) = item
            }
        }
    }

    fn handle_transfer_list() {
        let chain = this.transfer
        let last_list = chain.olist_last
        let last_index = chain.index
        let first_list = chain.olist_first
        let next_list = first_list

        // Mark solid
        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if @ptrv(item, u8, 0) != state_transfer {
                    continue
                }
                if @ptrv(item, u8, 1) != state_solid {
                    continue
                }
                Stack.transfer_to_solid_rec(item)
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
            if next_list == 0 @as ptr {
                break
            }
        }

        // Mark unknown
        next_list = first_list
        let unknown = this.unknown
        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if @ptrv(item, u8, 0) != state_transfer {
                    continue
                }
                if @ptrv(item, u8, 1) != state_unknown {
                    continue
                }
                Stack.transfer_to_unknown_rec(item, unknown)
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
            if next_list == 0 @as ptr {
                break
            }
        }

        chain.olist_last = first_list
        chain.index = 0
    }

    fn clean_new_list() {
        let chain = this.newbs
        let last_list = chain.olist_last
        let last_index = chain.index
        let next_list = chain.olist_first

        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                let state = @ptrv(item, u8, 0)
                if state == state_new {
                    // print("-")
                    // mem:free(item)
                    // atomic(gc_object_count - 1)
                    this.object_count--
                    continue
                }
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
        }

        chain.olist_last = chain.olist_first
        chain.index = 0
        this.bump.wipe()
    }

    fn clean_unknown_list() {
    }

    static fn transfer_to_solid_rec(item: ptr) {
        // 
        @ptrv(item, u8, 0) = state_solid @as u8
        let fields = @ptrv(item, u8, 2)
        while fields > 0 {
            let field = fields
            fields--
            let sub = @ptrv(item, ptr, field)
            if sub != 0 @as ptr {
                let substate = @ptrv(sub, u8, 0)
                if substate < state_solid {
                    Stack.transfer_to_solid_rec(sub)
                }
            }
        }
    }
    static fn transfer_to_unknown_rec(item: ptr, unknown: ObjectChain) {
        // 
        @ptrv(item, u8, 0) = state_unknown @as u8
        unknown.add_item(item)
        let fields = @ptrv(item, u8, 2)
        while fields > 0 {
            let field = fields
            fields--
            let sub = @ptrv(item, ptr, field)
            if sub != 0 @as ptr {
                let substate = @ptrv(sub, u8, 0)
                if substate < state_solid {
                    Stack.transfer_to_unknown_rec(sub, unknown)
                }
            }
        }
    }
}

