
use volt:mem
use volt:os

global stack : ?Stack;

value state_new (0)
value state_unknown (1)
value state_solid (2)
value inl_new (0)
value inl_unknown (1)
value inl_none (2)
value inl_transfer (3)
// state(u8)    0 new 1 unknown 2 solid
// in_list(u8)  0 new 1 unknown 2 none 3 transfer

struct Stack {
    data : ptr
    count : uint (0)
    object_count : uint (0)
    object_count_last : uint (0)
    lowest: uint (0)
    lowest_next : uint (0)
    unknown : ObjectChain
    transfer : ObjectChain
    newbs : ObjectChain
    move_checks : ObjectChain
    allow_gc : bool (false)
    bump: Bump

    static fn new() Stack {
        let unknown = ObjectChain.new(1)
        let transfer = ObjectChain.new(1)
        let newbs = ObjectChain.new(1)
        let move_checks = ObjectChain.new(1)
        let bump = Bump.new()

        let s = Stack {
            data: mem:alloc(100000)
            unknown: unknown
            transfer: transfer
            newbs: newbs
            move_checks: move_checks
            bump: bump
        }
        (gc_instance @as GC).add_stack(s);
        return s
    }

    static fn create_thread_stack() {
        let s = Stack.new()
        stack = s;
    }

    ///////////////////////
    // Stack items
    ///////////////////////
    fn reserve(amount: uint) ptr {
        let count = this.count
        let adr = this.data + (count * sizeof(ptr) * 2);
        this.count = count + amount
        return adr
    }
    fn pop(amount: uint) {
        let data = this.data;
        let count = this.count
        let new_count = count - amount
        if new_count < this.lowest_next {
            this.lowest_next = new_count
        }
        this.count = new_count;
        // if new_count == 0 {
            // print("stack_empty\n");
        // }
    }

    ///////////////////////
    // Allocate items
    ///////////////////////
    fn add_gc_object(item: ptr) {
        this.newbs.add_item(item)
        atomic(gc_object_count + 1)
        this.object_count++
    }

    ///////////////////////
    // Runtime functions
    ///////////////////////
    static fn gc_check() {
        let s = stack
        if s.allow_gc == false {
            if s.object_count < s.object_count_last * 2 {
                if s.count > s.lowest {
                    return
                }
            }
        }
        // print("gc\n")
        s.gc()
        s.allow_gc = false
        s.object_count_last = s.object_count
    }
    static fn link(on: ptr, to: ptr) ptr {
        return to
    }
    static fn unlink(from: ptr, item: ptr) {
    }

    ///////////////////////
    // Gc
    ///////////////////////
    fn gc() {
        let do_full_clear = false
        this.mark_difference_down()
        // Fast clear
        if do_full_clear == false {
            this.handle_transfer_list()
            this.clean_new_list()
            return
        }
        // Full clear
    }

    fn mark_difference_down() {
        let data = this.data
        let x = this.count
        while x > 0 {
            x--
            let index = x * 2
            let item = @ptrv(data, ptr, index);
            let item_prev = @ptrv(data, ptr, index + 1);
            if item != item_prev {
                // Stack position changed
                // Mark prev as unknown
                if item_prev != 0 @as ptr {
                    this.mark_unknown(item_prev)
                }
                // Mark new as solid recursive
                @ptrv(item, u8, 0) = state_solid @as u8
                if @ptrv(item, u8, 1) == inl_new {
                    let transfer = this.transfer
                    transfer.add_item(item)
                    @ptrv(item, u8, 1) = inl_transfer @as u8
                }
                // Overwrite prev
                @ptrv(data, ptr, index + 1) = item
            }
        }
    }

    fn mark_unknown(item: ptr) {
        @ptrv(item, u8, 0) = state_unknown @as u8
        let in_list = @ptrv(item, u8, 1)
        if in_list == inl_none {
            let unknown = this.unknown
            unknown.add_item(item)
            @ptrv(item, u8, 1) = inl_unknown @as u8
        }
    }

    fn handle_transfer_list() {
        let chain = this.transfer
        let last_list = chain.olist_last
        let last_index = chain.index
        let first_list = chain.olist_first
        let next_list = first_list

        // Mark solid
        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if @ptrv(item, u8, 1) != inl_none {
                    // Not in transfer list anymore
                    continue
                }
                let state = @ptrv(item, u8, 0)
                if state == state_solid {
                    Stack.transfer_to_solid_rec(item)
                    continue
                }
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
            if next_list == 0 @as ptr {
                break
            }
        }

        // Mark unknown
        next_list = first_list
        let unknown = this.unknown
        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if @ptrv(item, u8, 1) != inl_transfer {
                    // Not in transfer list anymore
                    continue
                }
                let state = @ptrv(item, u8, 0)
                if state == state_unknown {
                    Stack.transfer_to_unknown_rec(item, unknown)
                    continue
                }
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
            if next_list == 0 @as ptr {
                break
            }
        }

        chain.olist_last = first_list
        chain.index = 0
    }

    fn clean_new_list() {
        let chain = this.newbs
        let last_list = chain.olist_last
        let last_index = chain.index
        let next_list = chain.olist_first

        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                let state = @ptrv(item, u8, 0)
                if state == 0 {
                    // print("-")
                    // mem:free(item)
                    atomic(gc_object_count - 1)
                    this.object_count--
                    continue
                }
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
        }

        chain.olist_last = chain.olist_first
        chain.index = 0
        this.bump.wipe()
    }

    fn clean_unknown_list() {
    }

    static fn transfer_to_solid_rec(item: ptr) {
        // 
        @ptrv(item, u8, 1) = inl_none @as u8 // set list = none
        let fields = @ptrv(item, u8, 2)
        while fields > 0 {
            let field = fields
            fields--
            let sub = @ptrv(item, ptr, field)
            if sub != 0 @as ptr {
                @ptrv(sub, u8, 0) = state_solid @as u8 // set sub state = solid
                let in_list = @ptrv(sub, u8, 1)
                if in_list == inl_new {
                    Stack.transfer_to_solid_rec(sub)
                }
                if in_list == inl_transfer {
                    Stack.transfer_to_solid_rec(sub)
                }
            }
        }
    }
    static fn transfer_to_unknown_rec(item: ptr, unknown: ObjectChain) {
        // 
        @ptrv(item, u8, 1) = inl_unknown @as u8 // set list = unknown
        unknown.add_item(item)
        let fields = @ptrv(item, u8, 2)
        while fields > 0 {
            let field = fields
            fields--
            let sub = @ptrv(item, ptr, field)
            if sub != 0 @as ptr {
                let in_list = @ptrv(sub, u8, 1)
                if in_list == 0 {
                    @ptrv(sub, u8, 0) = state_unknown @as u8 // set sub state = unknown
                    Stack.transfer_to_unknown_rec(sub, unknown)
                }
            }
        }
    }

}

struct ObjectChain {
    olist_first : ptr
    olist_last : ptr
    index : int (0)
    trigger_count : int (0)
    trigger_reset : int (0)
    itemc: int (0)
    listc: int (0)

    static fn new(trigger_count: int) ObjectChain {
        let list = ObjectChain.new_olist();
        return ObjectChain {
            olist_first: list
            olist_last: list
            trigger_count: trigger_count
            trigger_reset: trigger_count
        }
    }

    static fn new_olist() ptr {
        let list = mem:alloc(102 * sizeof(ptr))
        @ptrv(list, ptr, 100) = 0 @as ptr
        return list
    }

    fn add_item(item: ptr) {
        let index_ = this.index;
        if index_ == 100 {
            let last_list = this.olist_last
            let next = @ptrv(last_list, ptr, 100)
            if next == (0 @as ptr) {
                next = ObjectChain.new_olist()
                @ptrv(last_list, ptr, 100) = next
                this.listc++
            }
            this.olist_last = next
            this.index = 0
        }
        let list = this.olist_last
        let index = this.index
        @ptrv(list, ptr, index) = item
        this.index = index + 1
        this.itemc++
    }
}

