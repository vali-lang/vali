
use volt:mem
use volt:os

global stack : ?Stack;

value state_new (0)
value state_transfer (2)
value state_solid (4)
value state_unknown (8)
value state_freed (16)
value state_global (32)
value stack_size (100000)

value sub_state_unknown (16)
value sub_state_keep (16)

value byte_moved (0)

struct Stack {
    stack_data : ptr
    stack_index : uint (0)
    stack_index_last : uint (0)

    space_transfered: uint (0)
    space_trigger : uint (10000)

    lowest: uint (0)
    lowest_next : uint (0)

    unknown : ObjectChain
    transfer : ObjectChain
    move_checks : ObjectChain

    bump: Bump

    run_gc_timeout : i32 (0)
    run_gc_full_timeout : i32 (0)

    age: u8 (32)
    stopping: bool (false)

    static fn new() Stack {
        let unknown = ObjectChain.new()
        let transfer = ObjectChain.new()
        let move_checks = ObjectChain.new()
        let bump = Bump.new()

        let data = alloc(stack_size)
        let stackc = stack_size / 8
        while stackc > 0 {
            stackc--
            @ptrv(data, ptr, stackc) = null
        }

        let s = Stack {
            stack_data: data
            unknown: unknown
            transfer: transfer
            move_checks: move_checks
            bump: bump
        }


        let gc = gc_instance;
        while gc == null {
            gc = gc_instance;
        }
        (gc @as Gc).add_stack(s);
        return s
    }

    static fn create_thread_stack() {
        let s = Stack.new()
        stack = s;
    }

    ///////////////////////
    // Stack items
    ///////////////////////
    fn reserve(amount: uint) ptr {
        let count = this.stack_index
        let bump = this.bump
        let space_added = bump.space_added
        if this.run_gc_timeout == 0 {
            this.gc()
        } else if (space_added > (bump.space_total >> 1)) {
            // Only gc when bump is atleast half full
            if (count <= this.lowest) {
                this.gc()
            } else if (space_added > this.space_trigger) {
                this.gc()
            }
        }
        let adr = this.stack_data + (count * sizeof(ptr) * 2);
        this.stack_index = count + amount
        return adr
    }
    fn pop(amount: uint) {
        let data = this.stack_data;
        let count = this.stack_index
        let new_count = count - amount
        if new_count < this.lowest_next {
            this.lowest_next = new_count
        }
        if new_count < this.lowest {
            this.lowest = new_count
        }
        this.stack_index = new_count;
    }

    ///////////////////////
    // Runtime functions
    ///////////////////////
    fn link(on: ptr, to: ptr) {
        let to_state = @ptrv(to, u8, 0)
        let on_state = @ptrv(on, u8, 0)
        if to_state == state_new {
            // Transfer
            this.transfer.add_item(to)
            @ptrv(to, u8, 0) = state_transfer @as u8
            @ptrv(to, u8, 1) = on_state @as u8
        } else if on_state == state_solid {
            // Update transfer state (if solid)
            @ptrv(to, u8, 1) = state_solid @as u8
        }
        // Add to move check list
        let in_list = @ptrv(on, u8, 3)
        if in_list == 0 {
            this.move_checks.add_item(on)
            @ptrv(on, u8, 3) = 1
        }
    }
    static fn unlink(item: ptr) {
        if item == (null) {
            return
        }
        let item_state = @ptrv(item, u8, 0)
        if item_state == state_solid {
            stack.unknown.add_item(item)
            @ptrv(item, u8, 0) = state_unknown @as u8
            @ptrv(item, u8, 1) = 0
        } else if item_state == state_transfer {
            // Update transfer state
            @ptrv(item, u8, 1) = state_unknown @as u8
        }
    }

    ///////////////////////
    // Gc
    ///////////////////////
    fn gc() {
        this.mark_difference_down()
        this.handle_transfer_list()
        this.check_moves()
        this.run_gc_timeout = 10 @as i32

        if this.run_gc_full_timeout == 0 {
            // Full clear
            this.clean_unknown_list()
            this.run_gc_full_timeout = 40 @as i32
        }

        // Update stack info
        let bump = this.bump
        let space_added = bump.space_added
        bump.wipe()
        let transfered = this.space_transfered

        let freed = space_added - transfered
        if transfered > freed {
            // Increase trigger
            this.space_trigger = space_added * 12 / 10
        } else {
            // Reduce trigger
            this.space_trigger = this.space_trigger * 100 / 99
        }

        this.space_transfered = 0
        this.stack_index_last = this.stack_index
    }

    fn mark_difference_down() {
        let data = this.stack_data
        let new_count = this.stack_index
        let last_count = this.stack_index_last
        let x = new_count
        if last_count > x {
            x = last_count
        }
        let transfer = this.transfer
        let unknown = this.unknown
        while x > 0 {
            x--
            let index = x * 2
            let item_prev = @ptrv(data, ptr, index + 1);
            if x < new_count {
                let item = @ptrv(data, ptr, index);
                if item != item_prev {
                    // Stack position changed
                    if item_prev != null {
                        // Mark prev as unknown
                        // let is_moved = (@ptrv(item_prev, u8, byte_moved) & 1) == 1
                        // if is_moved == false {
                            if @ptrv(item_prev, u8, 0) == state_solid {
                                unknown.add_item(item_prev)
                                @ptrv(item_prev, u8, 0) = state_unknown @as u8
                                @ptrv(item_prev, u8, 1) = 0
                            }
                        // }
                    }
                    if item != null {
                        // Make sure transfer state is solid
                        @ptrv(item, u8, 1) = state_solid @as u8
                        // Check if transfer needed
                        if @ptrv(item, u8, 0) == state_new {
                            transfer.add_item(item)
                            @ptrv(item, u8, 0) = state_transfer @as u8
                        } 
                    }
                    // Overwrite prev
                    @ptrv(data, ptr, index + 1) = item
                }
            } else {
                // 
                if item_prev != null {
                    // Mark prev as unknown
                    if @ptrv(item_prev, u8, 0) == state_solid {
                        unknown.add_item(item_prev)
                        @ptrv(item_prev, u8, 0) = state_unknown @as u8
                        @ptrv(item_prev, u8, 1) = 0
                    }
                }
                @ptrv(data, ptr, index + 1) = null
            }
        }
    }

    fn handle_transfer_list() {
        let chain = this.transfer
        let last_list = chain.olist_last
        let last_index = chain.index
        let first_list = chain.olist_first
        let next_list = first_list

        let count : uint = 0 @as uint
        let counter = @ptr_of(count)

        // Mark solid
        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if (@ptrv(item, u8, byte_moved) & 1) == 1 {
                    continue
                }
                if @ptrv(item, u8, 0) != state_transfer {
                    continue
                }
                if @ptrv(item, u8, 1) != state_solid {
                    continue
                }
                Stack.transfer_to_solid_rec(item, counter)
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
            if next_list == null {
                break
            }
        }

        // Mark unknown
        next_list = first_list
        let unknown = this.unknown
        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if (@ptrv(item, u8, byte_moved) & 1) == 1 {
                    continue
                }
                if @ptrv(item, u8, 0) != state_transfer {
                    continue
                }
                if @ptrv(item, u8, 1) != state_unknown {
                    continue
                }
                Stack.transfer_to_unknown_rec(item, unknown, counter)
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
            if next_list == null {
                break
            }
        }

        chain.olist_last = first_list
        chain.index = 0

        this.space_transfered = count
    }

    fn clean_unknown_list() {
        // Update age
        let new_age = 64 @as u8
        if this.age == 64 {
            new_age = 66
        }
        let age = new_age
        this.age = age
        //
        this.mark_stack_as_solid()

        let bump = this.bump
        bump.save_free_position()

        let chain = this.unknown
        let last_list = chain.olist_last
        let last_index = chain.index
        let next_list = chain.olist_first

        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if @ptrv(item, u8, 1) != age {
                    // Free item + all sub items with incorrect age and have solid state
                    Stack.free_rec(item, age, bump)
                }
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
        }

        chain.olist_last = chain.olist_first
        chain.index = 0

        bump.add_free_item(null)
        bump.free_all_items()
    }

    static fn free_rec(item: ptr, age: u8, bump: Bump) {
        bump.add_free_item(item)
        @ptrv(item, u8, 0) = state_freed

        let fields = @ptrv(item, u8, 2)
        while fields > 0 {
            let field = fields--
            let sub = @ptrv(item, ptr, field)
            if sub != null {
                let sub_state = @ptrv(sub, u8, 0)
                if sub_state == state_solid {
                    if @ptrv(sub, u8, 1) != age {
                        Stack.free_rec(sub, age, bump)
                    }
                }
            }
        }
    }

    fn mark_stack_as_solid() {
        let data = this.stack_data
        let x = this.stack_index
        let age = this.age
        while x > 0 {
            x--
            let index = x * 2
            let item = @ptrv(data, ptr, index);
            if item != null {
                if @ptrv(item, u8, 1) != age {
                    Stack.mark_stack_item_as_solid_rec(item, age)
                }
            }
        }
    }
    static fn mark_stack_item_as_solid_rec(item: ptr, age: u8) {
        @ptrv(item, u8, 1) = age

        let fields = @ptrv(item, u8, 2)
        while fields > 0 {
            let field = fields--
            let sub = @ptrv(item, ptr, field)
            if sub != null {
                if @ptrv(sub, u8, 1) != age {
                    Stack.mark_stack_item_as_solid_rec(sub, age)
                }
            }
        }
    }

    fn check_moves() {
        let chain = this.move_checks
        let last_list = chain.olist_last
        let last_index = chain.index
        let next_list = chain.olist_first

        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                let fields = @ptrv(item, u8, 2)
                while fields > 0 {
                    let field = fields--
                    let sub = @ptrv(item, ptr, field)
                    if sub != null {
                        let is_moved = (@ptrv(sub, u8, byte_moved) & 1) == 1
                        if is_moved {
                            // Adjust field
                            @ptrv(item, ptr, field) = @ptrv(sub, ptr, 0) - 1
                        }
                    }
                }

            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
        }

        chain.olist_last = chain.olist_first
        chain.index = 0

        // Check stack objects that have been moved
        let data = this.stack_data
        let x = this.stack_index
        while x > 0 {
            x--
            let index = x * 2
            let item = @ptrv(data, ptr, index);
            if (@ptrv(item, u8, byte_moved) & 1) == 1 {
                // Object was moved
                let new_item = @ptrv(item, ptr, 0) - 1

                @ptrv(data, ptr, index) = new_item
                @ptrv(data, ptr, index + 1) = new_item
            }
        }
    }

    static fn transfer_to_solid_rec(item: ptr, counter: ptr) ptr {
        // 
        let size = @ptrv(item, i32, 1) @as uint
        let new_item = alloc(size)
        copy(item, new_item, size)
        @ptrv(item, ptr, 0) = new_item | 1
        @ptrv(new_item, u8, 0) = state_solid @as u8

        @ptrv(counter, uint) += size

        let fields = @ptrv(new_item, u8, 2)
        while fields > 0 {
            let field = fields--
            let sub = @ptrv(item, ptr, field)
            if sub != null {
                if (@ptrv(sub, u8, byte_moved) & 1) == 1 {
                    // Already moved
                    @ptrv(new_item, ptr, field) = @ptrv(sub, ptr, 0) - 1
                    continue
                }
                if @ptrv(sub, u8, 0) < state_solid {
                    // transfer or new
                    @ptrv(new_item, ptr, field) = Stack.transfer_to_solid_rec(sub, counter)
                }
            }
        }
        return new_item
    }
    static fn transfer_to_unknown_rec(item: ptr, unknown: ObjectChain, counter: ptr) ptr {
        // 
        let size = @ptrv(item, i32, 1) @as uint
        let new_item = alloc(size)
        copy(item, new_item, size)
        @ptrv(item, ptr, 0) = new_item | 1
        @ptrv(new_item, u8, 0) = state_unknown @as u8
        @ptrv(new_item, u8, 1) = 0
        unknown.add_item(new_item)

        @ptrv(counter, uint) += size

        let fields = @ptrv(new_item, u8, 2)
        while fields > 0 {
            let field = fields--
            let sub = @ptrv(item, ptr, field)
            if sub != null {
                if (@ptrv(sub, u8, byte_moved) & 1) == 1 {
                    // Already moved
                    @ptrv(new_item, ptr, field) = @ptrv(sub, ptr, 0) - 1
                    continue
                }
                let substate = @ptrv(sub, u8, 0)
                if substate < state_solid {
                    // transfer or new
                    @ptrv(new_item, ptr, field) = Stack.transfer_to_unknown_rec(sub, unknown, counter)
                }
            }
        }
        return new_item
    }

    fn stop() {
        //
        this.gc()
        //
        this.transfer.delete()
        this.move_checks.delete()

        // Clear bump allocator
        let bump = this.bump
        bump.save_free_position()

        // Clear unknown list
        let chain = this.unknown
        let last_list = chain.olist_last
        let last_index = chain.index
        let next_list = chain.olist_first

        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if @ptrv(item, u8, 0) == state_unknown {
                    Stack.free_item_rec(item, bump)
                }
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
        }

        chain.delete()

        // Clear stack
        let data = this.stack_data
        let x = this.stack_index
        while x > 0 {
            x--
            let index = x * 2
            let item = @ptrv(data, ptr, index);
            let item_prev = @ptrv(data, ptr, index + 1);

            if @ptrv(item, u8, 0) == state_solid {
                Stack.free_item_rec(item, bump)
            } else if @ptrv(item, u8, 0) == state_unknown {
                Stack.free_item_rec(item, bump)
            }
            if @ptrv(item_prev, u8, 0) == state_solid {
                Stack.free_item_rec(item_prev, bump)
            } else if @ptrv(item_prev, u8, 0) == state_unknown {
                Stack.free_item_rec(item_prev, bump)
            }
        }

        // Free all items
        bump.add_free_item(null)
        bump.free_all_items()
        bump.delete()

        // Stack is deleted by the Gc
    }

    static fn free_item_rec(item: ptr, bump: Bump) {
        @ptrv(item, u8, 0) = state_freed
        bump.add_free_item(item)

        let fields = @ptrv(item, u8, 2)
        while fields > 0 {
            let field = fields--
            let sub = @ptrv(item, ptr, field)
            if sub != null {
                if @ptrv(sub, u8, 0) == state_solid {
                    Stack.free_item_rec(sub, bump)
                } else if @ptrv(sub, u8, 0) == state_unknown {
                    Stack.free_item_rec(sub, bump)
                }
            }
        }
    }
}

