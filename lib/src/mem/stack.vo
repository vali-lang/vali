
use volt:mem
use volt:os
use volt:io

global stack : ?Stack;
global allocator : ?Bump;

value state_new (0)
value state_transfer (2)
value state_solid (4)
value state_unknown (6)
value state_freed (8)
value state_freed2 (10)
value state_global (12)
value state_const (14)
value stack_size (1000000)

value sub_state_keep (5)
value sub_state_unknown (6)
value sub_state_on_stack (7)

value byte_moved (0)
value byte_state (0)
value byte_sub_state (1)
value byte_fields (2)
value byte_in_move_check_list (3)
value byte_uu1 (4) // unused 1
value byte_uu2 (5) // unused 2
// size : i32

value trigger_lowest (0)
value trigger_buffer_size (1)
value trigger_gc_count (2)

struct Stack {
    stack_base : ptr
    stack_adr : ptr
    stack_adr_last : ptr

    lowest: ptr
    lowest_next : ptr

    unknown : ObjectChain
    transfer : ObjectChain
    move_checks : ObjectChain

    bumper: Bumper
    bucket: BucketMan

    age: u8 (33)
    run_gc_type: u8 (trigger_lowest)

    run_gc: bool (false)
    force_full: bool (false)
    stopped: bool (false)
    disable: bool (false)

    static fn init() {
        let unknown = ObjectChain.new()
        let transfer = ObjectChain.new()
        let move_checks = ObjectChain.new()

        let data = alloc(stack_size)
        let stackc = stack_size / sizeof(ptr)
        while stackc > 0 {
            stackc--
            @ptrv(data, ptr, stackc) = null
        }

        let s = Stack {
            stack_base: data
            stack_adr: data
            stack_adr_last: data

            lowest: data
            lowest_next: data + (100 * sizeof(ptr))

            unknown: unknown
            transfer: transfer
            move_checks: move_checks

            bumper: Bumper.init()
            bucket: BucketMan.init()
        }

        stack = s;

        let gcm = gc_manager()
        gcm.add_stack(s);
    }

    ///////////////////////
    // Runtime functions
    ///////////////////////
    static fn link(on: ptr, to: ptr) ptr {
        let to_state = @ptrv(to, u8, 0)
        let on_state = @ptrv(on, u8, 0)
        if on_state == state_global {
            // TODO move item to global
            // print("TODO: MOVE TO GLOBAL")
            return to
        }
        if to_state == state_new {
            // Transfer
            stack.transfer.add_item(to)
            @ptrv(to, u8, 0) = state_transfer
            @ptrv(to, u8, 1) = state_unknown
        }
        if on_state == state_solid {
            // Update transfer state (if solid)
            @ptrv(to, u8, 1) = state_solid
        }
        return to
    }
    static fn unlink(item: ptr) {
        let item_state = @ptrv(item, u8, 0)
        if item_state == state_solid {
            stack.unknown.add_item(item)
            @ptrv(item, u8, 0) = state_unknown
            @ptrv(item, u8, 1) = 0
        } else if item_state == state_transfer {
            // Update transfer state
            @ptrv(item, u8, 1) = state_unknown
        }
    }

    ///////////////////////
    // Gc
    ///////////////////////
    fn gc(trigger_type: u8) {

        if this.disable {
            return
        }
        this.disable = true

        // io:print_fake("#")
        // io:print_fake("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n")
        this.mark_difference_down()
        this.handle_transfer_list()
        this.bumper.wipe()
        this.bucket.base = this.bucket.first
        this.bucket.index = 0

        // Full clear
        let unknown_count = this.unknown.itemc
        if this.force_full {
            this.force_full = false
            unknown_count = 1
        }
        if this.lowest_next < this.lowest {
            // When reaching a new low, do a full clear
            unknown_count = 1
            this.lowest = this.lowest_next
        }
        if unknown_count > 0 {
            // io:print_fake("f\n")
            this.clean_unknown_list()
            this.bucket.check_freed()
        }

        // Lowest stack point
        if trigger_type == trigger_lowest {
            io:print_fake("l\n")
            if this.stack_adr < this.lowest {
                this.lowest = this.stack_adr
            }
            this.lowest_next = this.stack_adr + (100000 * sizeof(ptr))
        } else if trigger_type == trigger_buffer_size {
            io:print_fake("b\n")
            // Increase lowest point
            this.lowest = this.lowest_next
            this.lowest_next = this.stack_adr + (100000 * sizeof(ptr))
        }


        this.stack_adr_last = this.stack_adr
        this.disable = false
    }

    fn mark_difference_down() {
        let transfer = this.transfer
        let unknown = this.unknown

        let stack_base = this.stack_base
        let stack_adr = this.stack_adr
        let adr_last = this.stack_adr_last

        // Mark previous items as: not on stack
        let adr = adr_last;
        // while adr >= stack_adr {
        //     adr = adr - sizeof(ptr) * 2
        // }

        // Mark items as: on stack
        // Mark new items as transfer
        adr = stack_adr;
        while adr > stack_base {
            let item_adr = adr - sizeof(ptr) * 2
            adr = item_adr
            let item = @ptrv(item_adr, ptr, 0);
            if item != null {
                //
                let state = @ptrv(item, u8, 0)
                if state == state_new {
                    // Transfer new items
                    transfer.add_item(item)
                    @ptrv(item, u8, 0) = state_transfer @as u8
                    @ptrv(item, u8, 1) = state_solid @as u8
                } 
                if state == state_transfer {
                    @ptrv(item, u8, 1) = state_solid @as u8
                } 

                @ptrv(item, u8, 2) = sub_state_on_stack
            }
        }

        // Previous items that are not on stack: add them to unknown
        // Set previous to null
        adr = adr_last;
        while adr > stack_base {
            let item_adr = adr - sizeof(ptr) * 2
            adr = item_adr
            let item_prev = @ptrv(item_adr, ptr, 1);
            if item_prev != null {
                if @ptrv(item_prev, u8, 2) != sub_state_on_stack {
                    if @ptrv(item_prev, u8, 0) == state_solid {
                        unknown.add_item(item_prev)
                        @ptrv(item_prev, u8, 0) = state_unknown @as u8
                    }
                }
                // Clear previous
                @ptrv(item_adr, ptr, 1) = null
            }
        }

        // Set previous to current
        adr = stack_adr;
        while adr > stack_base {
            let item_adr = adr - sizeof(ptr) * 2
            adr = item_adr
            let item = @ptrv(item_adr, ptr, 0);
            @ptrv(item_adr, ptr, 1) = item
            if item != null {
                @ptrv(item, u8, 2) = 0
            }
        }
    }

    fn handle_transfer_list() {
        let chain = this.transfer
        let last_list = chain.olist_last
        let last_index = chain.index
        let first_list = chain.olist_first
        let next_list = first_list

        // Mark solid
        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = chain_size
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if (@ptrv(item, u8, byte_moved) & 1) == 1 {
                    continue
                }
                if @ptrv(item, u8, 0) != state_transfer {
                    continue
                }
                if @ptrv(item, u8, 1) != state_solid {
                    continue
                }
                // Stack.transfer_to_solid_rec(item)
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, chain_size)
            if next_list == null {
                break
            }
        }

        // Mark unknown
        next_list = first_list
        let unknown = this.unknown
        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = chain_size
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if (@ptrv(item, u8, byte_moved) & 1) == 1 {
                    continue
                }
                if @ptrv(item, u8, 0) != state_transfer {
                    continue
                }
                if @ptrv(item, u8, 1) != state_unknown {
                    continue
                }
                // Stack.transfer_to_unknown_rec(item, unknown)
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, chain_size)
            if next_list == null {
                break
            }
        }

        chain.wipe()
    }

    fn clean_unknown_list() {
        // Update age
        let new_age = 64 @as u8
        if this.age == 64 {
            new_age = 66
        }
        let age = this.age + 1
        this.age = age

        //
        this.mark_stack_as_solid()

        let chain = this.unknown
        let last_list = chain.olist_last
        let last_index = chain.index
        let next_list = chain.olist_first

        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = chain_size
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if @ptrv(item, u8, 0) > state_unknown {
                    // Ignore freed, globals, consts
                    continue;
                }
                if @ptrv(item, u8, 1) != age {
                    // Free item + all sub items with incorrect age and have solid state

                    // Stack.free_rec(item, age, bump)
                }
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, chain_size)
        }

        chain.wipe()
    }

    fn mark_stack_as_solid() {
        let item_adr = this.stack_base
        let stack_adr = this.stack_adr
        let age = this.age
        while item_adr < stack_adr {
            let item = @ptrv(item_adr, ptr);
            if item != null {
                if @ptrv(item, u8, 0) < state_freed {
                    if @ptrv(item, u8, 1) != age {

                        // let table = @gc_get_vtable(vtable)
                        // let func = @ptrv(table, fn(ptr, u8)(void), 1)
                        // func(item, age);
                    }
                }
            }
            item_adr = item_adr + sizeof(ptr) * 2
        }
    }

    fn stop() {
        //
        this.force_full = true
        this.stack_adr = this.stack_base
        this.gc(trigger_lowest)
        //
        this.transfer.delete()
        this.unknown.delete()

        // Stack is deleted by the Gc
        this.stopped = true
    }


    fn print_stack() {
        // print("---------\n")
        // let item_adr = this.stack_base
        // let stack_adr = this.stack_adr + (sizeof(ptr) * 4)
        // while item_adr < stack_adr {
        //     let item = @ptrv(item_adr, ptr);
        //     print(item.to_hex())
        //     print("\n")
        //     item_adr = item_adr + sizeof(ptr) * 2
        // }
        // print("---------\n")
    }
}

