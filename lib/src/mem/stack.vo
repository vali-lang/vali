
use volt:mem

global stack : ?Stack;

struct Stack {
    data : ptr
    count : int (0)
    object_count : uint (0)
    delete_me : bool (false)
    chain_active : ObjectChain
    chains : ptr
    chainc : int

    static fn new() Stack {
        let active = ObjectChain.new(1)

        let chainc = 10
        let chains = mem:alloc(sizeof(ptr) * chainc @as uint)
        let i = 0
        while i < chainc {
            let chain = ObjectChain.new(i * 2 + 1)
            @ptrv(chains, ObjectChain, i++) = chain
        }

        let s = Stack {
            data: mem:alloc(100000)
            chain_active: active
            chains: chains
            chainc: chainc
        }
        (gc_instance @as GC).add_stack(s);
        return s
    }

    static fn create_thread_stack() {
        let s = Stack.new()
        stack = s;
    }

    ///////////////////////
    // Stack items
    ///////////////////////
    fn reserve(amount: int) ptr {
        let count = this.count
        let adr = this.data + (count * sizeof(ptr));
        let x = amount
        while x > 0 {
            @ptrv(adr, ptr, --x) = 0 @as ptr;
            // @ptrv(adr, ptr, --x) = 0 @as ptr;
        }
        this.count += amount
        return adr
    }
    fn pop(amount: int) {
        this.count -= amount;
    }

    fn mark() {
        let data = this.data
        let x = this.count
        let a = gc_age
        while x > 0 {
            let item = @ptrv(data, ptr, --x);
            if item == 0 @as ptr {
                continue
            }
            // Update age recursive
            let age = @ptrv(item, u8, 0)
            if age != a {
                @ptrv(item, u8, 0) = a
                Stack.update_age(item)
            }
        }
    }

    static fn update_age(item: ptr) {
        let fields = @ptrv(item, u8, 1)
        let a = gc_age
        while fields > 0 {
            let sub = @ptrv(item, ptr, fields--)
            if sub == 0 @as ptr {
                continue
            }
            // print("-")
            let age = @ptrv(sub, u8, 0)
            if age != a {
                @ptrv(sub, u8, 0) = a
                Stack.update_age(sub)
            }
        }
    }

    ///////////////////////
    // Allocated items
    ///////////////////////
    // Ran by the thread itself, uses active chain
    fn add_gc_object(item: ptr, handler: fn(ptr)(bool)) {
        let chain = this.chain_active;
        let index_ = chain.index;
        if index_ == 100 {
            let next = @ptrv(chain.olist_last, ptr, 100)
            if next == 0 @as ptr {
                next = ObjectChain.new_olist()
                @ptrv(chain.olist_last, ptr, 100) = next
            }
            chain.olist_last = next
            chain.index = 0
        }
        let index = chain.index
        let list = chain.olist_last
        @ptrv(list, ptr, index) = item
        chain.index = index + 1
        atomic(gc_object_count + 1)
    }

    // Ran by the GC, loop chains & delete unmarked
    fn delete_unmarked() {
        let chains = this.chains
        let chainc = this.chainc
        let i = 0
        while i < chainc {
            let chain = @ptrv(chains, ObjectChain, i++) 
            let next = chain
            if i < chainc {
                next = @ptrv(chains, ObjectChain, i) 
            }
            chain.trigger_count--
            if chain.trigger_count == 0 {
                chain.trigger_count = chain.trigger_reset
                Stack.delete_from_chain(chain, next)
            }
        }
    }

    static fn delete_from_chain(chain: ObjectChain, next: ObjectChain) {
        let list_next = chain.olist_first
        let last = chain.olist_last
        let last_index = chain.index

        let swap_isset = false
        let swap_list = next.olist_last
        let swap_index = next.index
        let a = gc_age

        if chain != next {
            swap_isset = true
            chain.olist_last = list_next
            chain.index = 0
        }

        while 1 == 1 {
            let list = list_next
            let is_last = false
            let max = 100
            if list == last {
                is_last = true;
                max = last_index
            }
            let max_ = max
            //
            let index = 0;
            while index < max_ {
                let item = @ptrv(list, ptr, index)
                let age = @ptrv(item, u8, 0)
                let keep = age == a
                if(keep) {
                    if swap_isset {
                        if swap_index == 100 {
                            let next = @ptrv(swap_list, ptr, 100)
                            if next == 0 @as ptr {
                                next = ObjectChain.new_olist()
                                @ptrv(swap_list, ptr, 100) = next
                            }
                            swap_list = next
                            swap_index = 0
                        }
                        @ptrv(swap_list, ptr, swap_index) = item
                        swap_index++
                    }
                }else{
                    mem:free(item);
                    atomic(gc_object_count - 1)
                    if swap_isset == false {
                        chain.olist_last = list
                        chain.index = index
                        swap_isset = true
                        swap_list = next.olist_last
                        swap_index = next.index
                    }
                }
                //
                index++
            }
            if is_last {
                break
            }
            list_next = @ptrv(list, ptr, 100)
        }

        next.olist_last = swap_list
        next.index = swap_index
    }

    fn swap_chains() {
        let chains = this.chains
        let active = this.chain_active
        let first = @ptrv(chains, ObjectChain, 0)
        @ptrv(chains, ObjectChain, 0) = active
        this.chain_active = first
    }
}

struct ObjectChain {
    olist_first : ptr
    olist_last : ptr
    index : int (0)
    trigger_count : int (0)
    trigger_reset : int (0)

    static fn new(trigger_count: int) ObjectChain {
        let list = ObjectChain.new_olist();
        return ObjectChain {
            olist_first: list
            olist_last: list
            trigger_count: trigger_count
            trigger_reset: trigger_count
        }
    }

    static fn new_olist() ptr {
        let list = mem:alloc(101 * sizeof(ptr))
        @ptrv(list, ptr, 100) = 0 @as ptr
        return list
    }
}

// x.prop = something
// if(gc == 1 && something.age != gc_age) {
//   something.update_age_recursive();
// }

// ---------

// fn update_age_recursive() {
//    atomic(gc_busy + 1)
//    this.mark_gc();
//    atomic(gc_busy - 1)
// }

// fn mark_gc() {
//    let age = atomic(this.age + 1);
//    if age != gc_age { atomic(this.age - 1); return }
   
//    // go over each prop
//    let prop = this.{prop-name}
//    if prop.age != age { prop.mark_gc(); }
// }
