
use volt:mem
use volt:os

global stack : ?Stack;

value state_new (0)
value state_transfer (2)
value state_solid (4)
value state_unknown (8)
value state_freed (16)
value stack_size (100000)

value sub_state_unknown (16)
value sub_state_keep (16)

value byte_moved (0)

struct Stack {
    data : ptr
    count : uint (0)
    count_last : uint (0)
    object_count : uint (0)
    object_count_last : uint (0)
    object_count_transfer : uint (0)
    object_count_trigger : uint (100)
    lowest: uint (0)
    lowest_next : uint (0)
    unknown : ObjectChain
    transfer : ObjectChain
    move_checks : ObjectChain
    to_be_free : ObjectChain
    bump: Bump
    run_gc_timeout : i32 (0)
    run_gc_full_timeout : i32 (0)
    age: u8 (32)

    static fn new() Stack {
        let unknown = ObjectChain.new()
        let transfer = ObjectChain.new()
        let move_checks = ObjectChain.new()
        let to_be_free = ObjectChain.new()
        let bump = Bump.new()

        let data = alloc(stack_size)
        let stackc = stack_size / 8
        while stackc > 0 {
            stackc--
            @ptrv(data, ptr, stackc) = null
        }

        let s = Stack {
            data: data
            unknown: unknown
            transfer: transfer
            move_checks: move_checks
            to_be_free: to_be_free
            bump: bump
        }


        (gc_instance @as GC).add_stack(s);
        return s
    }

    static fn create_thread_stack() {
        let s = Stack.new()
        stack = s;
    }

    ///////////////////////
    // Stack items
    ///////////////////////
    fn reserve(amount: uint) ptr {
        let count = this.count
        if this.run_gc_timeout == 0 {
            // print("_")
            this.gc()
        } else if (count <= this.lowest) {
            // print("l")
            this.gc()
        // } else if (this.object_count > this.object_count_trigger) {
        //     this.gc()
        }
        let adr = this.data + (count * sizeof(ptr) * 2);
        this.count = count + amount
        return adr
    }
    fn pop(amount: uint) {
        let data = this.data;
        let count = this.count
        let new_count = count - amount
        if new_count < this.lowest_next {
            this.lowest_next = new_count
        }
        if new_count < this.lowest {
            this.lowest = new_count
        }
        this.count = new_count;
    }

    ///////////////////////
    // Runtime functions
    ///////////////////////
    // fn link(on: ptr, to: ptr) ptr {
    //     return to
    //     if to == null {
    //         return to
    //     }
    //     let to_state = @ptrv(to, u8, 0)
    //     if to_state > state_transfer {
    //         return to
    //     }
    //     let on_state = @ptrv(on, u8, 0)
    //     if on_state > state_transfer {
    //         if to_state == state_new {
    //             // Transfer
    //             this.transfer.add_item(to)
    //             @ptrv(to, u8, 0) = state_transfer @as u8
    //             @ptrv(to, u8, 1) = on_state @as u8
    //         } else if on_state == state_solid {
    //             // Update transfer state (if solid)
    //             @ptrv(to, u8, 1) = state_solid @as u8
    //         }
    //         // Add to move check list
    //         let in_list = @ptrv(on, u8, 3)
    //         if in_list == 0 {
    //             this.move_checks.add_item(on)
    //             @ptrv(on, u8, 3) = 1
    //         }
    //     }
    //     return to
    // }
    static fn unlink(item: ptr) {
        if item == (null) {
            return
        }
        let item_state = @ptrv(item, u8, 0)
        if item_state == state_solid {
            stack.unknown.add_item(item)
            @ptrv(item, u8, 0) = state_unknown @as u8
            @ptrv(item, u8, 1) = 0
        } else if item_state == state_transfer {
            // Update transfer state
            @ptrv(item, u8, 1) = state_unknown @as u8
        }
    }

    ///////////////////////
    // Gc
    ///////////////////////
    fn gc() {
        this.mark_difference_down()
        this.handle_transfer_list()
        this.check_moves()
        this.bump.wipe()
        this.run_gc_timeout = 10 @as i32

        if this.run_gc_full_timeout == 0 {
            // Full clear
            this.clean_unknown_list()
            this.run_gc_full_timeout = 40 @as i32
        }

        // Update counters
        let tc = this.object_count_transfer
        if tc > 0 {
        print(tc.to_str())
        print("<\n")
        }
        let new_ob_count = this.object_count_last + this.object_count_transfer
        this.object_count = new_ob_count
        this.object_count_last = new_ob_count
        this.object_count_trigger = (new_ob_count + 100) * 15 / 10
        this.object_count_transfer = 0
        this.count_last = this.count
    }

    fn mark_difference_down() {
        let data = this.data
        let new_count = this.count
        let last_count = this.count_last
        let x = new_count
        if last_count > x {
            x = last_count
        }
        let transfer = this.transfer
        let unknown = this.unknown
        while x > 0 {
            x--
            let index = x * 2
            let item_prev = @ptrv(data, ptr, index + 1);
            if x < new_count {
                let item = @ptrv(data, ptr, index);
                if item != item_prev {
                    // Stack position changed
                    if item_prev != null {
                        // Mark prev as unknown
                        // let is_moved = (@ptrv(item_prev, u8, byte_moved) & 1) == 1
                        // if is_moved == false {
                            if @ptrv(item_prev, u8, 0) == state_solid {
                                unknown.add_item(item_prev)
                                @ptrv(item_prev, u8, 0) = state_unknown @as u8
                                @ptrv(item_prev, u8, 1) = 0
                            }
                        // }
                    }
                    if item != null {
                        // Make sure transfer state is solid
                        @ptrv(item, u8, 1) = state_solid @as u8
                        // Check if transfer needed
                        if @ptrv(item, u8, 0) == state_new {
                            transfer.add_item(item)
                            @ptrv(item, u8, 0) = state_transfer @as u8
                        } 
                    }
                    // Overwrite prev
                    @ptrv(data, ptr, index + 1) = item
                }
            } else {
                // 
                if item_prev != null {
                    // Mark prev as unknown
                    if @ptrv(item_prev, u8, 0) == state_solid {
                        unknown.add_item(item_prev)
                        @ptrv(item_prev, u8, 0) = state_unknown @as u8
                        @ptrv(item_prev, u8, 1) = 0
                    }
                }
                @ptrv(data, ptr, index + 1) = null
            }
        }
    }

    fn handle_transfer_list() {
        let chain = this.transfer
        let last_list = chain.olist_last
        let last_index = chain.index
        let first_list = chain.olist_first
        let next_list = first_list

        let count : uint = 0 @as uint
        let counter = @ptr_of(count)

        // Mark solid
        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if (@ptrv(item, u8, byte_moved) & 1) == 1 {
                    continue
                }
                if @ptrv(item, u8, 0) != state_transfer {
                    continue
                }
                if @ptrv(item, u8, 1) != state_solid {
                    continue
                }
                Stack.transfer_to_solid_rec(item, counter)
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
            if next_list == null {
                break
            }
        }

        // Mark unknown
        next_list = first_list
        let unknown = this.unknown
        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if (@ptrv(item, u8, byte_moved) & 1) == 1 {
                    continue
                }
                if @ptrv(item, u8, 0) != state_transfer {
                    continue
                }
                if @ptrv(item, u8, 1) != state_unknown {
                    continue
                }
                Stack.transfer_to_unknown_rec(item, unknown, counter)
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
            if next_list == null {
                break
            }
        }

        chain.olist_last = first_list
        chain.index = 0

        this.object_count_transfer = count
    }

    fn clean_unknown_list() {
        // Update age
        let new_age = 32 @as u8
        if this.age == 32 {
            new_age = 34
        }
        let age = new_age
        this.age = age
        //
        this.mark_stack_as_solid()

        let chain = this.unknown
        let last_list = chain.olist_last
        let last_index = chain.index
        let next_list = chain.olist_first
        let free_list = this.to_be_free

        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                if @ptrv(item, u8, 1) != age {
                    // Free item + all sub items with incorrect age and have solid state
                    Stack.free_rec(item, age, free_list)
                }
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
        }

        chain.olist_last = chain.olist_first
        chain.index = 0

        Stack.free_items(free_list)
    }

    static fn free_rec(item: ptr, age: u8, free_list: ObjectChain) {
        free_list.add_item(item)
        @ptrv(item, u8, 0) = state_freed

        let fields = @ptrv(item, u8, 2)
        while fields > 0 {
            let field = fields--
            let sub = @ptrv(item, ptr, field)
            if sub != null {
                let sub_state = @ptrv(sub, u8, 0)
                if sub_state == state_solid {
                    if @ptrv(sub, u8, 1) != age {
                        Stack.free_rec(sub, age, free_list)
                    }
                }
            }
        }
    }

    static fn free_items(free_list: ObjectChain) {
        let chain = free_list
        let last_list = chain.olist_last
        let last_index = chain.index
        let next_list = chain.olist_first

        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                free(item)
            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
        }

        chain.olist_last = chain.olist_first
        chain.index = 0
    }

    fn mark_stack_as_solid() {
        let data = this.data
        let x = this.count
        let age = this.age
        while x > 0 {
            x--
            let index = x * 2
            let item = @ptrv(data, ptr, index);
            if item != null {
                if @ptrv(item, u8, 1) != age {
                    Stack.mark_stack_item_as_solid_rec(item, age)
                }
            }
        }
    }
    static fn mark_stack_item_as_solid_rec(item: ptr, age: u8) {
        @ptrv(item, u8, 1) = age

        let fields = @ptrv(item, u8, 2)
        while fields > 0 {
            let field = fields--
            let sub = @ptrv(item, ptr, field)
            if sub != null {
                let is_moved = (@ptrv(sub, u8, byte_moved) & 1) == 1
                if is_moved {
                    print("__MOVED__")
                    // print((sub @as uint).to_hex())
                    print((@ptrv(sub, ptr, 0) @as uint).to_hex())
                }

                if @ptrv(sub, u8, 1) != age {
                    Stack.mark_stack_item_as_solid_rec(sub, age)
                }
            }
        }
    }

    fn check_moves() {
        let chain = this.move_checks
        let last_list = chain.olist_last
        let last_index = chain.index
        let next_list = chain.olist_first

        while true {
            let list = next_list
            let index = 0
            let is_last = list == last_list
            let until_ = 100
            if is_last {
                until_ = last_index
            }
            let until = until_
            while index < until {
                let item = @ptrv(list, ptr, index)
                index++
                // Item logic
                let fields = @ptrv(item, u8, 2)
                while fields > 0 {
                    let field = fields--
                    let sub = @ptrv(item, ptr, field)
                    if sub != null {
                        let is_moved = (@ptrv(sub, u8, byte_moved) & 1) == 1
                        if is_moved {
                            // Adjust field
                            @ptrv(item, ptr, field) = @ptrv(sub, ptr, 0) - 1
                        }
                    }
                }

            }
            if is_last {
                break
            }
            next_list = @ptrv(list, ptr, 100)
        }

        chain.olist_last = chain.olist_first
        chain.index = 0

        // Check stack objects that have been moved
        let data = this.data
        let x = this.count
        while x > 0 {
            x--
            let index = x * 2
            let item = @ptrv(data, ptr, index);
            if (@ptrv(item, u8, byte_moved) & 1) == 1 {
                // Object was moved
                let new_item = @ptrv(item, ptr, 0) - 1

                @ptrv(data, ptr, index) = new_item
                @ptrv(data, ptr, index + 1) = new_item
            }
        }
    }

    static fn transfer_to_solid_rec(item: ptr, counter: ptr) ptr {
        // 
        let size = @ptrv(item, i32, 1) @as uint
        let new_item = alloc(size)
        copy(item, new_item, size)
        @ptrv(item, ptr, 0) = new_item | 1
        @ptrv(new_item, u8, 0) = state_solid @as u8

        @ptrv(counter, uint)++

        let fields = @ptrv(new_item, u8, 2)
        while fields > 0 {
            let field = fields--
            let sub = @ptrv(item, ptr, field)
            if sub != null {
                if (@ptrv(sub, u8, byte_moved) & 1) == 1 {
                    // Already moved
                    @ptrv(new_item, ptr, field) = @ptrv(sub, ptr, 0) - 1
                    continue
                }
                if @ptrv(sub, u8, 0) < state_solid {
                    // transfer or new
                    @ptrv(new_item, ptr, field) = Stack.transfer_to_solid_rec(sub, counter)
                }
            }
        }
        return new_item
    }
    static fn transfer_to_unknown_rec(item: ptr, unknown: ObjectChain, counter: ptr) ptr {
        // 
        let size = @ptrv(item, i32, 1) @as uint
        let new_item = alloc(size)
        copy(item, new_item, size)
        @ptrv(item, ptr, 0) = new_item | 1
        @ptrv(new_item, u8, 0) = state_unknown @as u8
        @ptrv(new_item, u8, 1) = 0
        unknown.add_item(new_item)

        @ptrv(counter, uint)++

        let fields = @ptrv(new_item, u8, 2)
        while fields > 0 {
            let field = fields--
            let sub = @ptrv(item, ptr, field)
            if sub != null {
                if (@ptrv(sub, u8, byte_moved) & 1) == 1 {
                    // Already moved
                    @ptrv(new_item, ptr, field) = @ptrv(sub, ptr, 0) - 1
                    continue
                }
                let substate = @ptrv(sub, u8, 0)
                if substate < state_solid {
                    // transfer or new
                    @ptrv(new_item, ptr, field) = Stack.transfer_to_unknown_rec(sub, unknown, counter)
                }
            }
        }
        return new_item
    }
}

