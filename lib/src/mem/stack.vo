
use volt:mem

global stack : ?Stack;

struct Stack {
    data : ptr
    count : int (0)
    delete_me : bool (false)
    chain_active : ObjectChain
    chain1 : ObjectChain
    chain2 : ObjectChain
    object_count : uint (0)

    static fn new() Stack {
        let c1 = ObjectChain.new()
        let c2 = ObjectChain.new()
        let s = Stack {
            data: mem:alloc(100000)
            chain_active: c1
            chain1: c1
            chain2: c2
        }
        (gc_instance @as GC).add_stack(s);
        return s
    }

    static fn create_thread_stack() {
        let s = Stack.new()
        stack = s;
    }

    ///////////////////////
    // Stack items
    ///////////////////////
    fn reserve(amount: int) ptr {
        let count = this.count
        let adr = this.data + (count * sizeof(ptr) * 2);
        let x = amount * 2
        while x > 0 {
            @ptrv(adr, ptr, --x) = 0 @as ptr;
            @ptrv(adr, ptr, --x) = 0 @as ptr;
        }
        this.count += amount
        return adr
    }
    fn pop(amount: int) {
        this.count -= amount;
    }

    fn mark() {
        let data = this.data
        let x = this.count * 2
        while x > 0 {
            let handler = @ptrv(data, fn(ptr)(), --x);
            let item = @ptrv(data, ptr, --x);
            if handler @as ptr != 0 @as ptr {
                if item != 0 @as ptr {
                    handler(item)
                }
            }
        }
    }

    ///////////////////////
    // Allocated items
    ///////////////////////
    // Ran by the thread itself, uses active chain
    fn add_gc_object(item: ptr, handler: fn(ptr)(bool)) {
        let chain = this.chain_active;
        let index_ = chain.index;
        if index_ == 200 {
            let next = @ptrv(chain.olist_last, ptr, 200)
            if next == 0 @as ptr {
                next = ObjectChain.new_olist()
                @ptrv(chain.olist_last, ptr, 200) = next
            }
            chain.olist_last = next
            chain.index = 0
        }
        let index = chain.index
        let list = chain.olist_last
        @ptrv(list, ptr, index) = item
        @ptrv(list, fn(ptr)(bool), index + 1) = handler
        chain.index = index + 2
        atomic(gc_object_count + 1)
    }

    // Ran by the GC, uses inactive chain
    fn delete_unmarked() {
        let inactive = this.get_inactive_chain()
        let list_next = inactive.olist_first
        let last = inactive.olist_last

        let swap_isset = false
        let swap_list = last
        let swap_index = inactive.index

        while 1 == 1 {
            let list = list_next
            let is_last = false
            let last_index_ = 200
            if list == last {
                is_last = true;
                last_index_ = inactive.index
            }
            let last_index = last_index_
            //
            let index = 0;
            while index < last_index {
                let item = @ptrv(list, ptr, index)
                let handler = @ptrv(list, fn(ptr)(bool), index + 1)
                let keep = handler(item)
                if(keep) {
                    if swap_isset {
                        if swap_index == 200 {
                            swap_list = @ptrv(swap_list, ptr, 200)
                            swap_index = 0
                        }
                        @ptrv(swap_list, ptr, swap_index) = item
                        @ptrv(swap_list, fn(ptr)(bool), swap_index + 1) = handler
                        swap_index += 2
                    }
                }else{
                    // @ptrv(list, ptr, index) = 0 @as ptr
                    atomic(gc_object_count - 1)
                    if swap_isset == false {
                        swap_isset = true
                        swap_list = list
                        swap_index = index
                    }
                }
                //
                index += 2
            }
            if is_last {
                break
            }
            list_next = @ptrv(list, ptr, 200)
        }

        inactive.olist_last = swap_list
        inactive.index = swap_index
    }

    fn get_inactive_chain() ObjectChain {
        let ca = this.chain_active
        if this.chain_active == this.chain1 {
            return this.chain2
        }
        return this.chain1
    }

    fn swap_chains() {
        let ca = this.chain_active
        let c1 = this.chain1
        let c2 = this.chain2
        if c1 == ca {
            this.chain_active = c2
        } else {
            this.chain_active = c1
        }
    }
}

struct ObjectChain {
    olist_first : ptr
    olist_last : ptr
    index : int (0)

    static fn new() ObjectChain {
        let list = ObjectChain.new_olist();
        return ObjectChain {
            olist_first: list
            olist_last: list
        }
    }

    static fn new_olist() ptr {
        let list = mem:alloc(101 * sizeof(ptr) * 2)
        @ptrv(list, ptr, 200) = 0 @as ptr
        return list
    }
}

// x.prop = something
// if(gc == 1 && something.age != gc_age) {
//   something.update_age_recursive();
// }

// ---------

// fn update_age_recursive() {
//    atomic(gc_busy + 1)
//    this.mark_gc();
//    atomic(gc_busy - 1)
// }

// fn mark_gc() {
//    let age = atomic(this.age + 1);
//    if age != gc_age { atomic(this.age - 1); return }
   
//    // go over each prop
//    let prop = this.{prop-name}
//    if prop.age != age { prop.mark_gc(); }
// }
