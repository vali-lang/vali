
use volt:mem

global stack : ?Stack;

struct Stack {
    data : ptr
    count : int (0)
    delete_me : bool (false)
    chain_active : ObjectChain
    chain1 : ObjectChain
    chain2 : ObjectChain
    object_count : uint (0)

    static fn new() Stack {
        let c1 = ObjectChain.new()
        let c2 = ObjectChain.new()
        let s = Stack {
            data: mem:alloc(100000)
            chain_active: c1
            chain1: c1
            chain2: c2
        }
        (gc_instance @as GC).add_stack(s);
        return s
    }

    static fn create_thread_stack() {
        let s = Stack.new()
        stack = s;
    }

    ///////////////////////
    // Stack items
    ///////////////////////
    fn reserve(amount: int) ptr {
        let count = this.count
        let adr = this.data + (count * sizeof(ptr) * 2);
        let x = amount * 2
        while x > 0 {
            @ptrv(adr, ptr, --x) = 0 @as ptr;
            @ptrv(adr, ptr, --x) = 0 @as ptr;
        }
        this.count += count
        return adr
    }
    fn pop(amount: int) {
        this.count -= amount;
    }

    fn mark() {
        let data = this.data
        let x = this.count * 2
        while x > 0 {
            let item = @ptrv(data, ptr, --x);
            let handler = @ptrv(data, ptr, --x);
        }
    }

    ///////////////////////
    // Allocated items
    ///////////////////////
    fn add_gc_object(item: ptr, handler: ptr) {
        let chain = this.chain_active;
        let index_ = chain.index;
        if index_ == 200 {
            let new_list = ObjectChain.new_olist()
            @ptrv(chain.olist_last, ptr, 200) = new_list
            chain.olist_last = new_list
            chain.index = 0
        }
        let index = chain.index
        let list = chain.olist_last
        @ptrv(list, ptr, index) = item
        @ptrv(list, ptr, index + 1) = handler
        chain.index = index + 2
        this.object_count++
    }

    fn delete_unmarked() {
        let ca = this.get_inactive_chain()
        let list_next = ca.olist_first
        let last = ca.olist_last
        let last_index = ca.index
        let swap_isset = false
        let swap_list = list_next
        let swap_index = 0
        while 1 == 1 {
            let list = list_next
            let is_last = false
            let last_index_ = 200
            if list == last {
                is_last = true;
                last_index_ = ca.index
            }
            let last_index = last_index_
            //
            let index = 0;
            while index < last_index {
                let item = @ptrv(list, ptr, index)
                let handler = @ptrv(list, fn(ptr)(bool), index + 1)
                let keep = handler(item)
                if(keep) {
                    if swap_isset {
                        @ptrv(swap_list, ptr, swap_index) = item
                        @ptrv(swap_list, fn(ptr)(bool), swap_index + 1) = handler
                    }
                }else{
                    // @ptrv(list, ptr, index) = 0 @as ptr // optional
                    this.object_count--
                    if swap_isset == false {
                        swap_list = list
                        swap_index = index
                    }
                }
                //
                index += 2
            }
            if is_last {
                break
            }
            list_next = @ptrv(list, ptr, 200)
            index = 0
        }
    }

    fn get_inactive_chain() ObjectChain {
        let ca = this.chain_active
        if this.chain_active == this.chain1 {
            return this.chain2
        }
        return this.chain1
    }

    fn swap_chains() {
        let ca = this.chain_active
        let c1 = this.chain1
        let c2 = this.chain2
        if c1 == ca {
            this.chain_active = c2
        } else {
            this.chain_active = c1
        }
    }
}

struct ObjectChain {
    olist_first : ptr
    olist_last : ptr
    index : int (0)

    static fn new() ObjectChain {
        let list = ObjectChain.new_olist();
        return ObjectChain {
            olist_first: list
            olist_last: list
        }
    }

    static fn new_olist() ptr {
        return mem:alloc(101 * sizeof(ptr) * 2)
    }
}

// x.prop = something
// if(gc == 1 && something.age != gc_age) {
//   something.update_age_recursive();
// }

// ---------

// fn update_age_recursive() {
//    atomic(gc_busy + 1)
//    this.mark_gc();
//    atomic(gc_busy - 1)
// }

// fn mark_gc() {
//    let age = atomic(this.age + 1);
//    if age != gc_age { atomic(this.age - 1); return }
   
//    // go over each prop
//    let prop = this.{prop-name}
//    if prop.age != age { prop.mark_gc(); }
// }
