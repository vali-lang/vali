
use volt:mem
use volt:os

shared gc_manager_instance : ?GcManager

fn gc_manager() GcManager {
    let gc = gc_manager_instance
    while gc == null {
        gc = gc_manager_instance
    }
    return gc @as GcManager
}

struct GcManager {
    stacks : ptr
    stack_count : uint (0)
    free_index : uint(0)
    free_index_lock : uint (0)
    has_free_index : bool (false)

    static fn init() {
        if gc_manager_instance != null {
            return
        }
        gc_manager_instance = GcManager {
            stacks: mem:alloc(2000 * sizeof(ptr))
        }
        os:Thread.start_without_gc(GcManager.loop @as ptr)
    }

    fn add_stack(s: Stack) {
        let index = 0 @as uint
        let has_index = false
        if(this.has_free_index) {
            let lock = atomic(this.free_index_lock + 1)
            if lock == this.free_index {
                index = lock
                has_index = true
                atomic(this.free_index_lock - lock)
                this.has_free_index = false
            } else {
                atomic(this.free_index_lock - 1)
            }
        }
        if has_index == false {
            index = atomic(this.stack_count + 1)
        }
        @ptrv(this.stacks, Stack, index) = s
    }

    static fn loop() {
        let g = gc_manager_instance;
        let cycles = 0
        let x = 0 @as uint;
        while true {
            x++
            let sc = g.stack_count;
            let stacks = g.stacks;
            // Loop stacks
            let si = sc;
            while si > 0 {
                si--
                let s = @ptrv(stacks, Stack, si);
                if s @as ?Stack == null {
                    if g.has_free_index == false {
                        g.free_index = si
                        atomic(g.free_index_lock + si)
                        g.has_free_index = true
                    }
                    continue;
                }
                if s.stopped {
                    @ptrv(stacks, ?Stack, si) = null
                    free(s @as ptr)
                    continue
                }
                // s.clear_unknown = true
            }
            os:sleep_ms(100)
        }
    }
}
