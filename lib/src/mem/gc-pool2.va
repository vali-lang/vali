
use io

struct GcPool2[T] {
    blockc: uint
    first: ptr
    block: ptr
    index: uint (0)

    static fn init() CLASS {
        let blockc : uint = 1
        let block = CLASS.create_block(blockc * 20)
        return CLASS{
            blockc: blockc
            first: block
            block: block
        }
    }
    static fn create_block(size: uint) ptr {
        if size > 250 : size = 250
        let bytes = size * (sizeof(inline T) + 8) + sizeof(ptr) * 3
        let b = calloc(bytes)
        @ptrv(b, ?ptr, 0) = null // next block
        @ptrv(b, uint, 1) = size // total
        @ptrv(b, uint, 2) = 0    // used
        return b
    }
    fn get_block() ptr {
        let block = this.block
        let index = this.index
        let count = @ptrv(block, uint, 1)
        while index < count {
            let item = block + sizeof(ptr) * 3 + index * (sizeof(inline T) + 8)
            if @ptrv(item, u8, byte_state) < state_solid {
                this.index = index
                return block
            }
            index++
        }
        let next = this.get_next_usable_block(@ptrv(block, ?ptr, 0), block)
        this.block = next
        this.index = 0
        return next
    }
    fn get_next_usable_block(block: ?ptr, last: ptr) ptr {
        while isset(block) {
            last = block
            if ((@ptrv(block, uint, 2) * 100 / @ptrv(block, uint, 1)) < 75) {
                return block
            }
            block = @ptrv(block, ?ptr, 0)
        }
        let blockc = this.blockc + 1
        this.blockc = blockc
        let new = CLASS.create_block(blockc * 2)
        @ptrv(last, ptr, 0) = new
        return new
    }

    fn get() T {
        let item = this.get_item()
        return (item + 8) @as T
    }

    fn get_item() ptr {
        // Increase list size if needed
        let block = this.get_block()
        let index = this.index

        let item : ptr = 0 @as ptr
        while true {
            item = block + sizeof(ptr) * 3 + index * (sizeof(inline T) + 8)
            if @ptrv(item, u8, byte_state) < state_solid {
                break
            }
            index = index + 1
        }

        // Defaults
        @ptrv(item, u32, 0) = 0
        @ptrv(item, u8, 1) = index @as u8
        @ptrv(item, u32, 1) = @type_vtable_index(T)

        // Update counters
        this.index = index + 1

        // Increment usage
        mem_new = mem_new + sizeof(inline T)
        mem_usage = mem_new * 100 / mem_marked
        if mem_usage > 50 {
            stack.run_gc = true
        }

        return item
    }

    fn swap_transfers() {
    }

    fn clean_unmarked(age: u8) {
        let current = this.block
        let ci = this.index
        let block = this.first
        let index = 0 @as uint

        while block != current {
            let b = block
            let count = @ptrv(block, uint, 1)
            while index < count {
                let item = b + sizeof(ptr) * 3 + index * (sizeof(inline T) + 8)
                let iage = @ptrv(item, u8, byte_age)
                let state = @ptrv(item, u8, byte_state)
                if iage != age && state == state_solid {
                    @ptrv(item, u8, byte_state) = state_new
                    // #if @type_has_method(T, _gc_free)
                    // let ob = (item + 8) @as T
                    // ob._gc_free()
                    // #end
                    @ptrv(b, uint, 2)--
                }
                index++
            }
            // Next block
            block = @ptrv(block, ptr, 0)
            index = 0
        }
        while index != ci {
            let b = current
            let item = b + sizeof(ptr) * 3 + index * (sizeof(inline T) + 8)
            let iage = @ptrv(item, u8, byte_age)
            let state = @ptrv(item, u8, byte_state)
            if iage != age && state == state_solid {
                @ptrv(item, u8, byte_state) = state_new
                // #if @type_has_method(T, _gc_free)
                // let ob = (item + 8) @as T
                // ob._gc_free()
                // #end
                @ptrv(b, uint, 2)--
            }
            index++
        }
    }

    fn reset() {
        this.index = 0
        this.block = this.get_next_usable_block(this.first, this.first)
    }
}
