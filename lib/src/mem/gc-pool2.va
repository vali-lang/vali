
use io

value GP_DATA_OFFSET (sizeof(ptr) * 4)

struct GcPool2[T] {
    blockc: uint
    first: ptr
    block: ptr
    index: uint (0)
    isize: uint (0)

    static fn init() CLASS {
        let isize : uint = (sizeof(inline T) + 8) @as uint
        let blockc : uint = 1
        let block = CLASS.create_block(blockc * 2, isize)
        return CLASS{
            blockc: blockc
            first: block
            block: block
            isize: isize
        }
    }
    static fn create_block(size: uint, isize: uint) ptr {
        if size > 248 : size = 248
        let b = alloc(size * isize + GP_DATA_OFFSET)
        // Settings
        @ptrv(b, ?ptr, 0) = null // next block
        @ptrv(b, uint, 1) = size // count
        @ptrv(b, uint, 2) = 0 // used
        @ptrv(b, uint, 3) = 0 // skip
        // Set indexes
        let data = b + GP_DATA_OFFSET
        let i : uint = 0
        while i < size {
            let item : ptr = data + i * isize
            @ptrv(item, u8, 0) = state_new
            @ptrv(item, u8, 1) = i @as u8
            @ptrv(item, u16, 1) = 0
            @ptrv(item, u32, 1) = @type_vtable_index(T)
            i++
        }
        return b
    }

    fn get() T {
        let isize = this.isize
        while true {
            let block = this.block
            if @ptrv(block, uint, 3) == 1 {
                this.set_next_block(block)
                continue
            }
            let index = this.index
            if index == @ptrv(block, uint, 1) {
                this.set_next_block(block)
                continue
            }
            this.index++
            let data = block + GP_DATA_OFFSET
            let item = data + index * isize
            if @ptrv(item, u8, byte_state) != state_new {
                continue
            }

            // Increment usage
            mem_new = mem_new + sizeof(inline T)
            mem_usage = mem_new * 100 / mem_marked
            if mem_usage > 50 {
                stack.run_gc = true
            }

            return (item + 8) @as T
        }
        exit(1)
    }

    fn set_next_block(block: ptr) {
        let next = @ptrv(block, ?ptr, 0)
        if isset(next) {
            this.set_block(next)
        } else {
            // Create new block
            let blockc = ++this.blockc
            let new = CLASS.create_block(blockc * 2, this.isize)
            // Set next
            @ptrv(block, ptr, 0) = new
            this.set_block(new)
        }
    }

    fn set_block(block: ptr) {
        this.block = block
        this.index = 0
    }

    fn swap_transfers() {
    }

    fn clean_unmarked(age: u8) {
        let current = this.block
        let block = this.first

        while block != current {
            let b = block
            let count = @ptrv(b, uint, 1)
            let used = @ptrv(b, uint, 2)
            // Loop items
            let i : uint = 0
            let data = b + GP_DATA_OFFSET
            while i < count {
                let item = data + i * this.isize
                let iage = @ptrv(item, u8, byte_age)
                if iage != age && @ptrv(item, u8, byte_state) == state_solid {
                    @ptrv(item, u8, byte_state) = state_new
                    @ptrv(item, u16, 1) = 0
                    used--
                }
                i++
            }

            @ptrv(b, uint, 2) = used

            block = @ptrv(block, ptr, 0)
        }
    }

    fn reset() {
        //
        let current = this.block
        let block = this.first
        while block != current {
            let b = block
            let count = @ptrv(b, uint, 1)
            let used = @ptrv(b, uint, 2)
            @ptrv(b, int, 3) = (used * 100 / count > 70) ? 1 : 0

            block = @ptrv(block, ptr, 0)
        }
        //
        this.set_block(this.first)
    }
}
