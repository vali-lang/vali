
use io

value GCP_BLOCK_BYTE_SETTINGS (3)
value GCP_BLOCK_PTR_SETTINGS (sizeof(ptr) * 2)
value GCP_BLOCK_SETTINGS_SIZE (GCP_BLOCK_PTR_SETTINGS + GCP_BLOCK_BYTE_SETTINGS)

struct GcPool2[T] {
    blockc: uint
    first: ptr
    block: ptr
    index: uint (0)
    isize: uint (0)

    static fn init() CLASS {
        let isize : uint = ((sizeof(inline T) + 8) @as uint).round_up(sizeof(ptr))
        let blockc : uint = 1
        let block = CLASS.create_block(blockc * 2, isize)
        return CLASS{
            blockc: blockc
            first: block
            block: block
            isize: isize
        }
    }
    static fn create_block(size: uint, isize: uint) ptr {
        if size > 248 : size = 248
        let bytes1 : uint = (GCP_BLOCK_SETTINGS_SIZE + size).round_up(sizeof(ptr))
        let bytes2 : uint = size * isize
        let b = calloc(bytes1 + bytes2)
        // Ptr settings
        let data = b + bytes1
        @ptrv(b, ?ptr, 0) = null // next block
        @ptrv(b, ptr, 1) = data // data section
        // Byte settings
        let byte_settings = b + GCP_BLOCK_PTR_SETTINGS
        @ptrv(byte_settings, u8, 0) = size @as u8 // item count
        @ptrv(byte_settings, u8, 1) = 0 // new index
        @ptrv(byte_settings, u8, 2) = 0 // solid index
        // Set indexes
        let indexes = b + GCP_BLOCK_SETTINGS_SIZE
        let end = size @as u8
        let i : u8 = 0
        while i < end {
            @ptrv(indexes, u8, i) = i
            i++
        }
        // exit(1)
        return b
    }

    fn get() T {
        let item = this.get_item()
        return (item + 8) @as T
    }

    fn get_item() ptr {
        // Increase list size if needed
        let block = this.block
        while true {
            let bset = block + GCP_BLOCK_PTR_SETTINGS
            let count = @ptrv(bset, u8, 0)
            let new_index = @ptrv(bset, u8, 1)
            if new_index == count {
                // Next block
                let next = @ptrv(block, ?ptr, 0)
                if isset(next) : block = next
                else {
                    // Create new block
                    let blockc = this.blockc + 1
                    let new = CLASS.create_block(blockc * 2, this.isize)
                    this.blockc = blockc
                    // Set next
                    @ptrv(block, ptr, 0) = new
                    block = new
                }
                this.block = block
                continue
            }
            // New item
            let data = @ptrv(block, ptr, 1)
            let index = @ptrv(bset + GCP_BLOCK_BYTE_SETTINGS, u8, new_index)
            let item = data + index * this.isize

            // Update index
            @ptrv(bset, u8, 1) = new_index + 1

            // Defaults
            @ptrv(item, u32, 0) = 0
            @ptrv(item, u8, 1) = index @as u8
            @ptrv(item, u32, 1) = @type_vtable_index(T)

            // Increment usage
            mem_new = mem_new + sizeof(inline T)
            mem_usage = mem_new * 100 / mem_marked
            if mem_usage > 50 {
                stack.run_gc = true
            }

            return item
        }
        exit(1)
    }

    fn swap_transfers() {
        let current = this.block
        let block = this.first

        while true {
            let b = block
            let data = @ptrv(b, ptr, 1)
            let bset = b + GCP_BLOCK_PTR_SETTINGS
            let count = @ptrv(bset, u8, 0)
            let new_index = @ptrv(bset, u8, 1)
            let sol_index = @ptrv(bset, u8, 2)
            let swap = sol_index
            let indexes = b + GCP_BLOCK_SETTINGS_SIZE
            while sol_index < new_index {
                let index = @ptrv(indexes, u8, sol_index)
                let item = data + index * this.isize
                let state = @ptrv(item, u8, byte_state)
                if state == state_solid {
                    if sol_index != swap {
                        @ptrv(indexes, u8, sol_index) = @ptrv(indexes, u8, swap)
                        @ptrv(indexes, u8, swap) = index
                    }
                    swap++
                }
                // if state == state_new {
                // TODO call _gc_free
                // }
                sol_index++
            }
            @ptrv(bset, u8, 1) = swap // new_index
            @ptrv(bset, u8, 2) = swap // sol_index
            // Stop after current
            if block == current : break
            // Check next
            let next = @ptrv(b, ?ptr, 0)
            if isset(next) {
                block = next
                continue
            }
            break
        }
    }

    fn clean_unmarked(age: u8) {
        let current = this.block
        let block = this.first

        while true {
            let b = block
            let data = @ptrv(b, ptr, 1)
            let bset = b + GCP_BLOCK_PTR_SETTINGS
            let count = @ptrv(bset, u8, 0)
            let i : u8 = 0
            let sol_index = @ptrv(bset, u8, 2)
            let swap = sol_index
            let indexes = b + GCP_BLOCK_SETTINGS_SIZE
            while i < sol_index {
                let index = @ptrv(indexes, u8, i)
                let item = data + index * this.isize
                let state = @ptrv(item, u8, byte_state)
                let iage = @ptrv(item, u8, byte_age)
                if iage != age && state == state_solid {
                    sol_index--
                    @ptrv(indexes, u8, i) = @ptrv(indexes, u8, sol_index)
                    @ptrv(indexes, u8, sol_index) = index
                    // TODO call _gc_free
                } else {
                    i++
                }
            }
            @ptrv(bset, u8, 1) = sol_index // new_index
            @ptrv(bset, u8, 2) = sol_index // sol_index
            // Stop after current
            if block == current : break
            // Check next
            let next = @ptrv(b, ?ptr, 0)
            if isset(next) {
                block = next
                continue
            }
            break
        }
    }

    fn reset() {
        this.block = this.first
    }
}
