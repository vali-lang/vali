
header "sys" as sys;

use os;
use io;
use utils;

class Connection {
    ~ fd: FD
    ~ open: bool (true)

    fn close() {
        if this.open == false { return }
        Socket.close(this.fd);
        this.open = false;
    }

    fn send_from_ptr(data: ptr, bytes_to_send: uint) !connection {

        if this.open == false { throw connection }

        while true {
            #if OS == win
            let wbytes = sys:send(this.fd, data, bytes_to_send @as i32, 0);
            #else
            let wbytes = sys:send(this.fd @as i32, data, bytes_to_send, 0);
            #end

            if wbytes < 0 {
                #if OS == win
                let err = os:WSA_error()
                if err == sys:WSAEWOULDBLOCK {
                    // EAGAIN
                    await_fd(this.fd, false, true)
                    continue;
                }
                #else
                let err = os:libc_errno()
                if err == sys:EAGAIN {
                    // EAGAIN
                    await_fd(this.fd, false, true)
                    continue;
                }
                #end
                throw connection;
            }
            if wbytes == 0 {
                throw connection;
            }

            let bytes_sent = wbytes @as uint
            if bytes_sent < bytes_to_send {
                data += bytes_sent
                bytes_to_send -= bytes_sent
                await_fd(this.fd, false, true)
                continue
            }

            if bytes_sent == bytes_to_send : return
            throw connection
        }
    }

    fn recv(buffer: utils:ByteBuffer, bytes: uint) uint !connection {

        if this.open == false { return 0 }

        buffer.minimum_free_space(bytes);
        let count : uint = 0;

        while true {
            #if OS == win
            let rcvd = sys:recv(this.fd, buffer.data + buffer.length, bytes @as i32, 0);
            #else
            let rcvd = sys:recv(this.fd @as i32, buffer.data + buffer.length, bytes, 0);
            #end
            if (rcvd < 0) {
                #if OS == win
                let err = os:WSA_error()
                if err == sys:WSAEWOULDBLOCK {
                    // EAGAIN
                    await_fd(this.fd, true, false)
                    continue;
                }
                #else
                let err = os:libc_errno()
                if err == sys:EAGAIN {
                    // EAGAIN
                    await_fd(this.fd, true, false)
                    continue;
                }
                #end
                throw connection;
            }
            if rcvd == 0 : throw connection;
            count = rcvd @as uint;
            break
        }
            
        buffer.length += count;
        return count;
    }

    fn _gc_free() {
        this.close()
    }
}
