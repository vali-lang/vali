
header "sys" as sys;
// header "openssl" as ossl;

use io;
use utils;

struct Connection {
    ~ fd: uint
    ~ open: bool (true)
    // ~ ssl_enabled: bool = false;
    // - ssl: ?SSL = null;


    // fn ssl_connect() !ssl_error {
    //     if this.ssl_enabled : return;
    //     let ssl = SSL.new(this.fd);
    //     let err = ossl.SSL_connect(ssl.ssl);
    //     if err != 1 {
    //         throw ssl_error;
    //     }
    //     this.ssl = ssl;
    //     this.ssl_enabled = true;
    // }

    fn close() {
        if this.open == false { return }
        Socket.close(this.fd);
        this.open = false;
    }

    fn send(buffer: utils:ByteBuffer) uint !connection !again {
        if buffer.read_index >= buffer.length { return 0 }
        let bytes_to_send = buffer.length - buffer.read_index;
        let bytes_sent = this.send_from_ptr(buffer.data + buffer.read_index, bytes_to_send) err ! {
            if error_is(err, !again) {
                throw again
            }
            throw connection
        }
        buffer.read_index += bytes_sent;
        return bytes_sent
    }

    fn send_from_ptr(data: ptr, bytes_to_send: uint) uint !connection !again {

        if this.open == false { throw connection }

        // let ssl = this.ssl;
        let bytes_sent : uint = 0;

        // if isset(ssl) {
        //     // SSL
        //     let wbytes = ossl.SSL_write(ssl.ssl, buffer.data + buffer.read_index, bytes_to_send @as i32);
        //     if wbytes <= 0 {
        //         // SSL_ERROR_WANT_WRITE: 3
        //         let err = ossl.SSL_get_error(ssl.ssl, wbytes);
        //         if err != 0 {
        //             if err == 3 {
        //                 throw e_again;
        //             }
        //             throw connection;
        //         }
        //         return 0;
        //     }
        //     bytes_sent = wbytes @as uint;

        // } else {
            // No SSL
            #if OS == win
            let wbytes = sys:send(this.fd, data, bytes_to_send @as i32, 0);
            #else
            let wbytes = sys:send(this.fd @as i32, data, bytes_to_send, 0);
            #end

            if wbytes < 0 {
                #if OS == win
                let err = sys:WSAGetLastError();
                if err == sys:WSAENOBUFS {
                    // EAGAIN
                    throw again;
                }
                #else
                #if OS == macos
                let err = @ptrv(sys:__error(), i32, 0);
                #else
                let err = @ptrv(sys:__errno_location(), i32, 0);
                #end
                if err == sys:EAGAIN {
                    // EAGAIN
                    throw again;
                }
                #end
                throw connection;
            }
            if wbytes == 0 {
                return 0;
            }
            bytes_sent = wbytes @as uint;
        // }

        return bytes_sent;
    }

    fn recv(buffer: utils:ByteBuffer) uint !connection !again {

        if this.open == false { return 0 }

        let buf_size : uint = 65535;
        // let ssl = this.ssl;

        buffer.minimum_free_space(buf_size);
        let count : uint = 0;

        // if isset(ssl) {
        //     let rcvd = ossl.SSL_read(ssl.ssl, buffer.data + buffer.length, buf_size);
        //     if rcvd <= 0 {
        //         // SSL_ERROR_NONE: 0
        //         // SSL_ERROR_WANT_READ: 2
        //         // SSL_ERROR_ZERO_RETURN: 6
        //         let err = ossl.SSL_get_error(ssl.ssl, rcvd);
        //         if err != 0 {
        //             if err != 6 {
        //                 if err == 2 {
        //                     throw e_again;
        //                 }
        //                 throw connection;
        //             }
        //         }
        //         return 0;
        //     }
        //     count = rcvd @as uint;

        // } else {
            #if OS == win
            let rcvd = sys:recv(this.fd, buffer.data + buffer.length, buf_size @as i32, 0);
            #else
            let rcvd = sys:recv(this.fd @as i32, buffer.data + buffer.length, buf_size, 0);
            #end
            if (rcvd < 0) {
                #if OS == win
                let err = sys:WSAGetLastError();
                if err == sys:WSAENOBUFS {
                    // EAGAIN
                    throw again;
                }
                #else
                #if OS == macos
                let err = @ptrv(sys:__error(), i32, 0);
                #else
                let err = @ptrv(sys:__errno_location(), i32, 0);
                #end
                if err == sys:EAGAIN {
                    // EAGAIN
                    throw again;
                }
                #end
                throw connection;
            }
            if (rcvd == 0) {
                return 0;
            }
            count = rcvd @as uint;
        // }
            
        buffer.length += count;
        return count;
    }

    fn _gc_free() {
        this.close()
    }
}
