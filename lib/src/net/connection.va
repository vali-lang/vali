
header "sys" as sys;
// header "openssl" as ossl;

use os;
use io;
use utils;

struct Connection {
    ~ fd: FD
    ~ open: bool (true)
    // ~ ssl_enabled: bool = false;
    // - ssl: ?SSL = null;


    // fn ssl_connect() !ssl_error {
    //     if this.ssl_enabled : return;
    //     let ssl = SSL.new(this.fd);
    //     let err = ossl.SSL_connect(ssl.ssl);
    //     if err != 1 {
    //         throw ssl_error;
    //     }
    //     this.ssl = ssl;
    //     this.ssl_enabled = true;
    // }

    fn close() {
        if this.open == false { return }
        Socket.close(this.fd);
        this.open = false;
    }

    async fn send_from_ptr(data: ptr, bytes_to_send: uint) uint !connection {

        if this.open == false { throw connection }

        // let ssl = this.ssl;
        let bytes_sent : uint = 0;

        // if isset(ssl) {
        //     // SSL
        //     let wbytes = ossl.SSL_write(ssl.ssl, buffer.data + buffer.read_index, bytes_to_send @as i32);
        //     if wbytes <= 0 {
        //         // SSL_ERROR_WANT_WRITE: 3
        //         let err = ossl.SSL_get_error(ssl.ssl, wbytes);
        //         if err != 0 {
        //             if err == 3 {
        //                 throw e_again;
        //             }
        //             throw connection;
        //         }
        //         return 0;
        //     }
        //     bytes_sent = wbytes @as uint;

        // } else {
            // No SSL
        while true {
            #if OS == win
            let wbytes = sys:send(this.fd, data, bytes_to_send @as i32, 0);
            #else
            let wbytes = sys:send(this.fd @as i32, data, bytes_to_send, 0);
            #end

            if wbytes < 0 {
                #if OS == win
                let err = os:WSA_error()
                if err == sys:WSAEWOULDBLOCK {
                    // EAGAIN
                    await_fd(this.fd, false, true)
                    continue;
                }
                #else
                let err = os:libc_errno()
                if err == sys:EAGAIN {
                    // EAGAIN
                    await_fd(this.fd, false, true)
                    continue;
                }
                #end
                throw connection;
            }
            if wbytes == 0 {
                return 0;
            }
            bytes_sent = wbytes @as uint;
            break
        }

        return bytes_sent;
    }

    async fn recv(buffer: utils:ByteBuffer, bytes: uint) uint !connection {

        if this.open == false { return 0 }
        // let ssl = this.ssl;

        buffer.minimum_free_space(bytes);
        let count : uint = 0;

        // if isset(ssl) {
        //     let rcvd = ossl.SSL_read(ssl.ssl, buffer.data + buffer.length, buf_size);
        //     if rcvd <= 0 {
        //         // SSL_ERROR_NONE: 0
        //         // SSL_ERROR_WANT_READ: 2
        //         // SSL_ERROR_ZERO_RETURN: 6
        //         let err = ossl.SSL_get_error(ssl.ssl, rcvd);
        //         if err != 0 {
        //             if err != 6 {
        //                 if err == 2 {
        //                     throw e_again;
        //                 }
        //                 throw connection;
        //             }
        //         }
        //         return 0;
        //     }
        //     count = rcvd @as uint;

        // } else {
        while true {
            #if OS == win
            let rcvd = sys:recv(this.fd, buffer.data + buffer.length, bytes @as i32, 0);
            #else
            let rcvd = sys:recv(this.fd @as i32, buffer.data + buffer.length, bytes, 0);
            #end
            if (rcvd < 0) {
                #if OS == win
                let err = os:WSA_error()
                if err == sys:WSAEWOULDBLOCK {
                    // EAGAIN
                    await_fd(this.fd, true, false)
                    continue;
                }
                #else
                let err = os:libc_errno()
                if err == sys:EAGAIN {
                    // EAGAIN
                    await_fd(this.fd, true, false)
                    continue;
                }
                #end
                throw connection;
            }
            if (rcvd == 0) {
                return 0;
            }
            count = rcvd @as uint;
            break
        }
            
        buffer.length += count;
        return count;
    }

    fn _gc_free() {
        this.close()
    }
}
