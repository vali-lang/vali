
header "sys" as sys

use mem
use os

class SocketTCP {
    ~ host: String
    ~ fd: FD
    ~ port: u16
    ~ blocking: bool (true)
    - addrinfo: sys:libc_addrinfo
    - connection: ?Connection (null)

    static fn new(host: String, port: u16, blocking: bool (true)) SocketTCP !os_socket_create !invalid_host {

        #if OS == win
        os:WSA_init()
        #end

        #if OS == linux
        let flags : i32 = sys:SOCK_STREAM
        if blocking == false {
            flags = flags | sys:SOCK_NONBLOCK
        }
        let ufd = sys:socket(sys:AF_INET, flags, 0)
        let fd = ufd @as FD
        #else

        // Win & macos
        #if OS == macos
        let fd = sys:socket(sys:AF_INET, sys:SOCK_STREAM, 0)
        let ufd = fd @as FD
        let flags = sys:fcntl(fd, sys:F_GETFL, 0)
        if flags >= 0 && !blocking : sys:fcntl(fd, sys:F_SETFL, flags | sys:O_NONBLOCK)

        #elif OS == win
        let sock_fd = sys:socket(sys:AF_INET, sys:SOCK_STREAM, 0)
        let ufd = os:WSA_unix_fd(sock_fd)
        let fd = sock_fd @as FD
        let nonblock_v = 1 // 1 = non-blocking, 0 = blocking
        if !blocking : sys:ioctlsocket(fd, sys:FIONBIO, @ptr_of(nonblock_v))
        #end

        #end

        if ufd == -1 {
            //#if OS == win
            //println("WSA socket error: " + sys:WSAGetLastError())
            //#end
            throw os_socket_create
        }

        // Get host info
        let addrinfo = CLASS.get_addrinfo(host, port) ! {
            throw invalid_host
        }

        // Set timeout
        #if OS == win
        let timeout : i32 = 1000 * 5 // 5 seconds
        sys:setsockopt(sock_fd, sys:SOL_SOCKET, sys:SO_RCVTIMEO, @ptr_of(timeout), sizeof(i32))
        #else
        let timeout = @stack(sys:libc_timeval)
        timeout.tv_sec = 5
        timeout.tv_usec = 0
        sys:setsockopt(ufd, sys:SOL_SOCKET, sys:SO_RCVTIMEO, timeout, sizeof(inline sys:libc_timeval))
        #end

        return SocketTCP{
            host: host,
            port: port,
            fd: fd,
            blocking: blocking,
            addrinfo: addrinfo,
        }
    }

    // fn connect() Connection !connection_failed {

    // 	let c = this.connection ?? <{
    // 		let c = Connection {
    // 			fd: this.fd
    // 			open: false,
    // 		}
    // 		let res = share(c)
    // 		this.connection = c
    // 		return res
    // 	}

    // 	if !c.open {
    //     	#if OS == win
    // 		let err = sys:connect(this.fd, this.addrinfo.ai_addr, this.addrinfo.ai_addrlen @as i32)
    // 		#else
    // 		let err = sys:connect(this.fd, this.addrinfo.ai_addr, this.addrinfo.ai_addrlen)
    // 		#end
    // 		if err != 0 : throw connection_failed
    // 		c.open = true
    // 	}

    // 	return c
    // }

    fn bind() !get_addr_info !bind !listen {
        let yes : i32 = 1
        let yes_ptr = @ptr_of(yes)
        
        let err : i32 = 0

        sys:setsockopt(this.fd @autocast, sys:SOL_SOCKET, sys:SO_REUSEADDR, yes_ptr, sizeof(i32))
        err = sys:bind(this.fd @autocast, this.addrinfo.ai_addr, this.addrinfo.ai_addrlen @autocast)

        if err != 0 {
            throw bind
        }

        err = sys:listen(this.fd @autocast, 2000000)
        if err != 0 {
            throw listen
        }
    }

    - static fn get_addrinfo(host: String, port: u16) sys:libc_addrinfo !failed {

        let addrinfo : ?sys:libc_addrinfo = null
        let hints = @stack(sys:libc_addrinfo)
        mem:clear(hints, sizeof(inline sys:libc_addrinfo))

        hints.ai_family = sys:AF_INET
        hints.ai_socktype = sys:SOCK_STREAM
        hints.ai_flags = sys:AI_PASSIVE

        let chost = host.data
        let cport = port.to_str().data
        let err = sys:getaddrinfo(chost, cport, hints, @ptr_of(addrinfo))
        if err != 0 {
            throw failed
        }
        if addrinfo == null {
            throw failed
        }

        return addrinfo @as sys:libc_addrinfo
    }

    fn accept() Connection !error {
        let flags : i32 = 0
        #if OS == linux
        if this.blocking == false { flags = flags | sys:SOCK_NONBLOCK }
        let ufd = sys:accept4(this.fd @autocast, null, null, flags)
        let fd = ufd @as FD
        #else
        let os_fd = sys:accept(this.fd @autocast, null, null)
        #if OS == macos
        let ufd = os_fd
        let fd = os_fd @as FD
        if !this.blocking {
        	let flags = sys:fcntl(fd, sys:F_GETFL, 0)
        	if flags >= 0 : sys:fcntl(fd, sys:F_SETFL, flags | sys:O_NONBLOCK)
        }
        #end
        #if OS == win
        let ufd = os:WSA_unix_fd(os_fd)
        let fd = os_fd
        let nonblock_v = 1 // 1 = non-blocking, 0 = blocking
        if !this.blocking : sys:ioctlsocket(fd, sys:FIONBIO, @ptr_of(nonblock_v))
        #end
        #end
        if ufd == -1 {
            throw error
        }
        return Connection {
            fd: fd,
        }
    }

    fn clone() CLASS {
        return CLASS {
            host: this.host,
            fd: this.fd,
            port: this.port,
            blocking: this.blocking,
            addrinfo: CLASS.get_addrinfo(this.host, this.port) ? this.addrinfo @as sys:libc_addrinfo,
        }
    }

    fn _gc_free() {
    	sys:freeaddrinfo(this.addrinfo)
    }
}
