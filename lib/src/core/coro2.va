
use mem
use io

global run_coroutine : ?Coro2 (null)
global coro_poll : ?io:SimplePoll[Coro2] (null)
global g_coros : @ignu(Array[?Coro2])
global g_coro_indexes : @ignu(Pool[uint])
global g_coro_poll_count : uint
global g_coro_count : uint

global main_jmp_buf : @ignu(ptr)
global tmp_jmp_buf : @ignu(ptr)
global frame_ptr : @ignu(ptr)

class Coro2 {
    stack: mem:StackPos
    gc_stack: mem:StackPos
    result: ptr
    start_func: fn(Coro2)()
    handler: fn()()
    follow_up: ?Coro2 (null)
    g_list_index: uint (0)
    jmp_buf: inline [u8, 256]
    error: u32 (0)
    started: bool (false)
    done: bool (false)

    static fn new(handler: ptr, start_func: ptr, result_is_gc: bool) CLASS {

        let stack = mem:create_stack()
        let gc_stack = mem:create_stack()

        let coro = Coro2 {
            stack: stack
            gc_stack: gc_stack
            result: result_is_gc ? gc_stack.adr : stack.adr
            //
            start_func: start_func @as fn(Coro2)()
            handler: handler @as fn()()
        }

        let indexes = g_coro_indexes
        if indexes.count == 0 {
            let index = g_coros.push(coro)
            coro.g_list_index = index
        } else {
            let index = indexes.get() ? 0
            g_coros.set(index, coro) _
            coro.g_list_index = index
        }

        return coro
    }

    static fn get_poll() io:SimplePoll[Coro2] {
        let poll = coro_poll
        if poll == null {
            let p = io:SimplePoll[Coro2].new()
            coro_poll = p
            return p
        }
        return poll @as io:SimplePoll[Coro2]
    }

    //////////////
    // AWAIT
    //////////////

    fn await_coro(coro: Coro2) {
        let ob = coro
        let ref = ob.follow_up
        while isset(ref) {
            ob = ref
            ref = ref.follow_up
        }
        ob.follow_up = this
        if setjmp(@ptr_of(this.jmp_buf)) == 0 {
            longjmp(main_jmp_buf)
        }
    }

    fn await_fd(fd: FD, read: bool, write: bool) {
        let poll = Coro2.get_poll()
        poll.set(fd, this, read, write)
        g_coro_poll_count++
        if setjmp(@ptr_of(this.jmp_buf)) == 0 {
            longjmp(main_jmp_buf)
        }
    }

    //////////////
    // FLOW
    //////////////

    fn test() {
        let x = 1
        setjmp(tmp_jmp_buf)
        println(x++)
    }

    fn start() {
        // this.test()
        // longjmp(tmp_jmp_buf)
        //
        g_coro_count++

        let fp_start = @stackptr
        let start = this.start_func

        mem:stack_pos = this.gc_stack
        start(this)
        mem:stack_pos = mem:main_stack_pos

        let fp_end = @ptrv(@ptr_of(this.jmp_buf), ptr, 2)
        let fp_size = (fp_start - fp_end) @as uint
        //
        // println(fp_start)
        // println(fp_end)
        // println(fp_size)
        let stack = this.stack
        let entry = stack.adr + stack.size - fp_size
        mem:copy(fp_end, entry, fp_size)

        // @ptrv(@ptr_of(this.jmp_buf), ptr, 2) = entry
    }

    fn resume() {
        if this.done : return
        run_coroutine = this

        if setjmp(main_jmp_buf) == 0 {
            print("1.")
            mem:stack_pos = this.gc_stack
            longjmp(@ptr_of(this.jmp_buf))
            print("2.")
            return
        }
        mem:stack_pos = mem:main_stack_pos
        print("3.")

        if this.done {
            let next = this.follow_up
            if isset(next) {
                next.resume()
            }
        }
    }

    fn complete() {
        this.done = true
        g_coro_count--
        g_coros.set(this.g_list_index, null) _
        g_coro_indexes.add(this.g_list_index)
        longjmp(main_jmp_buf)
    }

    //////////////
    // LOOP
    //////////////

    static fn loop() {
        let poll = Coro2.get_poll()
        let all = g_coros
        while g_coro_count > 0 {
            each all as coro {
                if isset(coro) {
                    if coro.started == false {
                print("R.")
                        coro.started = true
                        coro.resume()
                print("D.")
                    }
                }
            }
            if g_coro_poll_count > 0 {
                let coros = poll.wait(-1)
                if coros.length == 0 {
                    break
                }
                g_coro_poll_count -= coros.length
                each coros as coro {
                    coro.resume()
                }
            }
        }
    }

    ///////////////////
    // GC
    ///////////////////

    --- static fn transfer_check() {
        let coros = g_coros

        each coros as coro {
            if isset(coro) {
                let base = coro.gc_stack.base
                let adr = coro.gc_stack.adr
                while adr > base {
                    adr -= sizeof(ptr)
                    mem:gc_transfer_item(@ptrv(adr, ptr, 0))
                }
            }
        }
    }

    fn _gc_mark() {
        let base = this.gc_stack.base
        let adr = this.gc_stack.adr
        while adr > base {
            adr -= sizeof(ptr)
            mem:gc_mark_item(@ptrv(adr, ptr, 0))
        }
    }
    fn _gc_mark_shared() {
        let base = this.gc_stack.base
        let adr = this.gc_stack.adr
        while adr > base {
            adr -= sizeof(ptr)
            mem:gc_mark_shared_item(@ptrv(adr, ptr, 0))
        }
    }

    fn _gc_free() {
        mem:free(this.stack)
        mem:free(this.gc_stack)
    }
}
