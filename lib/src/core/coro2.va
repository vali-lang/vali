
use mem
use io

global run_coroutine : ?Coro2 (null)
global coro_poll : ?io:SimplePoll[Coro2] (null)
global g_coros : @ignu(Array[?Coro2])
global g_coro_indexes : @ignu(Pool[uint])
global g_coro_poll_count : uint

global main_jmp_buf : @ignu(ptr)

class Coro2 {
    stack: ptr
    stack_adr: ptr
    gc_stack: ptr
    gc_stack_adr: ptr
    result: ptr
    start_func: fn(Coro2)()
    handler: fn()()
    follow_up: ?Coro2 (null)
    g_list_index: uint (0)
    jmp_buf: inline [u8, 256]
    error: u32 (0)
    started: bool (false)
    done: bool (false)

    static fn new(handler: ptr, start_func: ptr, result_is_gc: bool) CLASS {

        let stack_adr = mem:create_stack()
        let gc_stack_adr = mem:create_stack()

        let coro = Coro2 {
            stack: stack_adr
            stack_adr: stack_adr
            gc_stack: gc_stack_adr
            gc_stack_adr: gc_stack_adr
            result: result_is_gc ? gc_stack_adr : stack_adr
            //
            start_func: start_func @as fn(Coro2)()
            handler: handler @as fn()()
        }

        let indexes = g_coro_indexes
        if indexes.count == 0 {
            let index = g_coros.push(coro)
            coro.g_list_index = index
        } else {
            let index = indexes.get() ? 0
            g_coros.set(index, coro) _
            coro.g_list_index = index
        }

        return coro
    }

    static fn get_poll() io:SimplePoll[Coro2] {
        let poll = coro_poll
        if poll == null {
            let p = io:SimplePoll[Coro2].new()
            coro_poll = p
            return p
        }
        return poll @as io:SimplePoll[Coro2]
    }

    //////////////
    // AWAIT
    //////////////

    fn await_coro(coro: Coro2) {
        let ob = coro
        let ref = ob.follow_up
        while isset(ref) {
            ob = ref
            ref = ref.follow_up
        }
        ob.follow_up = this
    }

    fn await_fd(fd: FD, read: bool, write: bool) {
        let poll = Coro2.get_poll()
        poll.set(fd, this, read, write)
        g_coro_poll_count++
    }

    //////////////
    // FLOW
    //////////////

    fn resume() {
        if this.done : return
        run_coroutine = this

        if @setjmp(main_jmp_buf) == 0 {

            if !this.started {
                let start = this.start_func
                start(this)
            } else {
                @longjmp(this.jmp_buf)
            }
            return
        }

        if this.done {
            let next = this.follow_up
            if isset(next) {
                next.resume()
            }
        }
    }

    fn complete() {
        this.done = true
        g_coros.set(this.g_list_index, null) _
        g_coro_indexes.add(this.g_list_index)
        @longjmp(main_jmp_buf)
    }

    //////////////
    // LOOP
    //////////////

    static fn loop() {
        let poll = Coro2.get_poll()
        let coros = g_coros
        while g_coro_poll_count > 0 {
            let coros = poll.wait(-1)
            if coros.length == 0 {
                break
            }
            g_coro_poll_count -= coros.length
            each coros as coro {
                // coro.resume()
            }
        }
    }

    ///////////////////
    // GC
    ///////////////////

    --- static fn transfer_check() {
        let coros = g_coros

        each coros as coro {
            if isset(coro) {
                let base = coro.gc_stack
                let adr = coro.gc_stack_adr
                while adr > base {
                    adr -= sizeof(ptr)
                    mem:gc_transfer_item(@ptrv(adr, ptr, 0))
                }
            }
        }
    }

    fn _gc_mark() {
        let base = coro.gc_stack
        let adr = coro.gc_stack_adr
        while adr > base {
            adr -= sizeof(ptr)
            mem:gc_mark_item(@ptrv(adr, ptr, 0))
        }
    }
    fn _gc_mark_shared() {
        let base = coro.gc_stack
        let adr = coro.gc_stack_adr
        while adr > base {
            adr -= sizeof(ptr)
            mem:gc_mark_shared_item(@ptrv(adr, ptr, 0))
        }
    }

    fn _gc_free() {
        mem:free(this.stack)
        mem:free(this.gc_stack)
    }
}
