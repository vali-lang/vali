
use mem
use os
use io

global run_coroutine : ?Coro (null)
global coro_poll : ?io:SimplePoll[Coro] (null)

class Coro {
    stack: ptr
    gc_stack: ptr
    gc_item_count: uint
    result: ptr
    handler: fn()()
    resume_coro: ?Coro (null)
    // waiting_on_me: ?Array[Coro] (null)
    resume_index: u32 (0)
    error: u32 (0)
    done: bool (false)

    static fn new(stack_size: uint, gc_item_count: uint, result_offset: uint, result_is_gc: bool, handler: ptr) CLASS {
        let align = (sizeof(ptr) - (stack_size % sizeof(ptr))) % sizeof(ptr)
        let gc_size = gc_item_count * sizeof(ptr)
        let size = stack_size + align + gc_size
        let data = size == 0 ? (null @as ptr) : mem:calloc(size)
        let gc_stack = data + stack_size + align
        let result = <{
            if result_is_gc : return gc_stack + (result_offset * sizeof(ptr))
            return data + result_offset
        }

        let coro = CLASS {
            stack: data
            gc_stack: gc_stack
            gc_item_count: gc_item_count
            result: result
            handler: handler @as fn()()
        }
        let list = mem:coros
        list.add(coro)
        return coro
    }

    static fn get_poll() io:SimplePoll[Coro] {
        let poll = coro_poll
        if poll == null {
            let p = io:SimplePoll[Coro].new()
            coro_poll = p
            return p
        }
        return poll @as io:SimplePoll[Coro]
    }

    fn resume() {
        if this.done : return
        run_coroutine = this
        this.handler()

        if this.done {
            let next = this.resume_coro
            if isset(next) {
                next.resume()
            }
        }
    }

    fn await_coro(coro: Coro) {
        let ob = coro
        let ref = ob.resume_coro
        while isset(ref) {
            ob = ref
            ref = ref.resume_coro
        }
        ob.resume_coro = this
    }
    fn await_fd(fd: FD, read: bool, write: bool) {
        let poll = Coro.get_poll()
        poll.set(fd, this, read, write)
    }

    static fn loop() {
        print("loop")
        let poll = Coro.get_poll()
        let ring = mem:coros
        let to_run = array[Coro]{}
        while ring.length > 0 {
            let tail = ring.tail
            while tail != ring.head {
                let data = ring.data
                let coro = @ptrv(data, Coro, tail)
                // if (coro @as uint) < 10000 {
                //     println("INVALID CORO: ")
                //     (coro @as ptr).print()
                //     print("\n")
                //     println(tail)
                //     println(ring.size)
                //     println(ring.head)
                //     println(ring.tail)
                //     println(ring.length)
                //     os:exit(1)
                // }
                if coro.done {
                    ring.remove(tail)
                }

                // print((ring @as ptr).to_hex() + ": " + tail + "(" + ring.tail + "/" + ring.head + ", " + ring.size + ")\n")

                // Next
                tail++
                if tail == ring.size {
                    tail = 0
                }
            }

            // if to_run.length > 0 {
            //     each to_run as coro {
            //         coro.resume()
            //     }
            //     to_run.clear()
            //     continue;
            // }

            let coros = poll.wait(-1)
            if coros.length == 0 {
                os:sleep_ms(4000)
            }
            each coros as coro {
                coro.resume()
            }
        }
        print("stop-loop")
    }

    ///////////////////
    // GC list
    ///////////////////
    --- static fn transfer_check() {
        let ring = mem:coros
        let tail = ring.tail
        let head = ring.head
        let size = ring.size
        let data = ring.data
        while tail != head {
            let coro = @ptrv(data, Coro, tail)
            mem:gc_transfer_item(coro)
            coro._gc_transfer()

            // Next
            tail++
            if tail == size {
                tail = 0
            }
        }
    }

    --- static fn mark_all() {
        let ring = mem:coros
        let tail = ring.tail
        let head = ring.head
        let size = ring.size
        let data = ring.data
        while tail != head {
            let coro = @ptrv(data, Coro, tail)
            mem:gc_mark_item(coro)

            // Next
            tail++
            if tail == size {
                tail = 0
            }
        }
    }

    --- static fn mark_shared_all() {
        let ring = mem:coros
        let tail = ring.tail
        let head = ring.head
        let size = ring.size
        let data = ring.data
        while tail != head {
            let coro = @ptrv(data, Coro, tail)
            mem:gc_mark_shared_item(coro)

            // Next
            tail++
            if tail == size {
                tail = 0
            }
        }
    }

    ///////////////////
    // GC
    ///////////////////
    fn _gc_transfer() {
        let x = this.gc_item_count
        let data = this.gc_stack
        while x-- > 0 {
            mem:gc_transfer_item(@ptrv(data, ptr, x))
        }
    }
    fn _gc_mark() {
        let data = this.gc_stack
        let x = this.gc_item_count
        while x-- > 0 {
            mem:gc_mark_item(@ptrv(data, ptr, x))
        }
    }
    fn _gc_mark_shared() {
        let data = this.gc_stack
        let x = this.gc_item_count
        while x-- > 0 {
            mem:gc_mark_shared_item(@ptrv(data, ptr, x))
        }
    }
    fn _gc_free() {
        let s = this.stack
        if s != null : mem:free(s)
    }
}