
header "sys" as sys

use mem
use io
use os

class Poll[T] {
    - epoll_fd: i32 (0)
    - epoll_buffer: ptr
    - listeners: Array[Listener[T]] (Array[Listener[T]].new())
    - lsn_by_index: ptr
    - lsn_by_index_size: uint (20)
    - event_buf: sys:libc_epoll_event (sys:libc_epoll_event{
        events: 0
        data: null
    })

    static fn new() CLASS {

        let fd = sys:epoll_create(1)
        let poll = CLASS {
            epoll_fd: fd
            epoll_buffer: mem:alloc(40 * sizeof(inline sys:libc_epoll_event))
            lsn_by_index: null
        }
        return poll
    }

    fn wait(timeout: i32 (-1), buffer: ?Array[Listener[T]] (null)) Array[Listener[T]] {

        let events = isset(buffer) ? buffer : Array[Listener[T]].new()

        let ebuf = this.epoll_buffer
        let count_ = sys:epoll_wait(this.epoll_fd, ebuf, 10, timeout)
        if count_ <= 0 {
            os:sleep_ms(1)
            return events
        }
        let count = count_ @as uint
        let i : uint = 0
        while i < count {
            let ev = (ebuf + (i * sizeof(inline sys:libc_epoll_event))) @as sys:libc_epoll_event
            let lsn = ev.data @as Listener[T]
            lsn.set_events(ev.events)
            if lsn.has_stopped_the_connection() {
                this.listeners.remove_item(lsn)
            }
            events.push(lsn)
            i++
        }

        return events
    }

    fn create_listener(fd: i32, data: T) Listener[T] {
        let lsn = Listener[T] {
            epoll_fd: this.epoll_fd
            fd: fd
            data: data
        }

        let ev = this.event_buf
        ev.events = 0
        ev.data = lsn @as ptr
        let res = sys:epoll_ctl(this.epoll_fd, sys:EPOLL_CTL_ADD, fd, ev)
        if res != 0 {
            println("> Failed to add epoll listener")
        }

        lsn.update_epoll()
        this.listeners.push(lsn)

        return lsn
    }
}

class Listener[T] {
    data: T
    ~ epoll_fd: i32 (0)
    ~ fd: i32
    ~ detect_read: bool (false)
    ~ detect_write: bool (false)
    - detect_events: u32 (0)
    - events: u32 (0)
    - event_buf: sys:libc_epoll_event (sys:libc_epoll_event{
        events: 0
        data: null
    })

    fn set_events(events: u32) {
        this.events = events
    }

    fn has_read_request() bool {
        return (this.events & sys:EPOLLIN) > 0
    }
    fn has_write_request() bool {
        return (this.events & sys:EPOLLOUT) > 0
    }
    fn has_stopped_the_connection() bool {
        let evs = this.events
        return (evs & sys:EPOLLRDHUP) > 0 || (evs & sys:EPOLLHUP) > 0 || (evs & sys:EPOLLERR) > 0
    }

    fn detect_read_request(v: bool) {
        this.detect_read = v
        this.update_epoll()
    }
    fn detect_write_request(v: bool) {
        this.detect_write = v
        this.update_epoll()
    }
    fn update_epoll() {
        let ev : u32 = 0
        if this.detect_read {
            #if OS == linux
            ev = ev | sys:EPOLLIN
            #else
            ev = ev | sys:POLLIN
            #end
        }
        if this.detect_write {
            #if OS == linux
            ev = ev | sys:EPOLLOUT
            #else
            ev = ev | sys:POLLOUT
            #end
        }
        #if OS == linux
        ev = ev | sys:EPOLLRDHUP
        #elif OS == win
        //ev = ev | sys.OS.POLLHUP;
        #else
        ev = ev | sys.OS.POLLRDHUP;
        #end

        this.detect_events = ev

        let evo = this.event_buf
        evo.events = this.detect_events
        evo.data = this

        let res = sys:epoll_ctl(this.epoll_fd, sys:EPOLL_CTL_MOD, this.fd, evo)
    }
}

