
use mem;

struct StringConst {
    v1: u8 (0)
    v2: u8 (0)
    v3: u8 (0)
    v4: u8 (0)
    v5: u32 (0)
    data: ptr
    bytes: uint
}

class String {
    data: ptr
    bytes: uint

	/////////////////////
	// Clean
	/////////////////////

	fn trim(part: String) String {
		let res = this.ltrim(part);
		return res.rtrim(part);
	}

	fn rtrim(part: String) String {

		let part_bytes = part.bytes
		let part_data = part.data

		let data = this.data
		let len = this.bytes
		let data_end = data + len
		let offset : uint = 0
		while (offset + part_bytes <= len) && mem:equal(data_end - offset - part_bytes, part_data, part_bytes) {
            offset += part_bytes
		}
        if offset == 0 : return this

        return String.make_from_ptr(data, len - offset)
	}

	fn ltrim(part: String) String {
		let part_bytes = part.bytes
		let part_data = part.data

		let data = this.data
		let len = this.bytes
		let offset : uint = 0
		while (offset + part_bytes <= len) && mem:equal(data + offset, part_data, part_bytes) {
            offset += part_bytes
		}
        if offset == 0 : return this

        return String.make_from_ptr(data + offset, len - offset)
	}

	/////////////////////
	// Convert
	/////////////////////

    fn to_uint() uint !not_a_number {
        return 0
    }
    fn to_lower() String {
        return this
    }

	/////////////////////
	// Partials
	/////////////////////
    
    fn byte(index: uint) u8 {
        if index >= this.bytes : return 0
        return @ptrv(this.data, u8, index)
    }

    fn sub_str_bytes(byte_start_index: uint, byte_length: uint) String {

        let this_bytes = this.bytes;
        if(byte_start_index > this_bytes){
            return "";
        }
        if((byte_start_index + byte_length) > this_bytes){
            byte_length = this_bytes - byte_start_index;
        }
        if(byte_length == 0){
            return "";
        }
        let from = this.data + byte_start_index;
        let res = String.make_empty(byte_length);
        mem:copy(from, res.data, byte_length);
        return res;
    }

	/////////////////////
	// Create
	/////////////////////

    fn clone() String {
        return String.make_from_ptr(this.data, this.bytes)
    }

    // TODO: mark unsafe
    static fn make_empty(length: uint) String {
        if length == 0 : return ""
        let d = mem:alloc(length + 1)
        @ptrv(d, u8, length) = 0 // trailing 0 byte
        let str = String {
            data: d
            bytes: length
        }
        return str
    }

    // TODO: mark unsafe
    static fn make_from_ptr(data: ptr, length: uint) String {
        if length == 0 : return ""
        let s = String.make_empty(length);
        mem:copy(data, s.data, length)
        return s
    }

	/////////////////////
	// Internals
	/////////////////////

    fn _add(add: String) String {
        let this_len = this.bytes
        let add_len = add.bytes
        let len = this_len + add_len
        let s = CLASS.make_empty(len)
        let data = s.data;
        mem:copy(this.data, data, this_len)
        mem:copy(add.data, @ptr_offset(data, this_len), add_len + 1) // + 1 for 0 byte
        return s
    }

    fn _eq(cmp: String) bool {
        if this.bytes != cmp.bytes : return false 
        return mem:equal(this.data, cmp.data, this.bytes)
    }

    fn _gc_free() {
        mem:free(this.data)
    }
}
