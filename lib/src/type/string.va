
use mem
use utils
use io

- cstruct StringConst {
    v1: u8 (0)
    v2: u8 (0)
    v3: u8 (0)
    v4: u8 (0)
    v5: u32 (0)
    data: ptr
    bytes: uint
}

- cstruct CharStep {
    data: ptr
    bytes: uint
    pos: uint

    fn set(str: String) {
        this.data = str.data
        this.bytes = str.bytes
        this.pos = 0
    }

    fn next() u8 !end {
        let pos = this.pos
        let bytes = this.bytes
        let data = this.data
        if pos == bytes : throw end
        let byte : u8 = @ptrv(data, u8, pos)
        let bytec : u8 = 1
        if((byte & 128) > 0){
            byte = byte << 1
            while (byte & 128) > 0 {
                bytec++
                byte = byte << 1
            }
            if bytec > 4 : bytec = 1
            if pos + bytec > bytes : bytec -= (pos + bytec - bytes) @as u8
        }
        this.pos = pos + bytec
        return bytec
    }
}

struct String {
    data: ptr
    bytes: uint

    /////////////////////
    // UTF8
    /////////////////////

    fn chars() uint {
        let step = @stack(CharStep)
        step.set(this)
        let count : uint = 0
        while true {
            step.next() ! return count
            count++
        }
        return 0
    }

    /////////////////////
    // Start / Ends
    /////////////////////

    fn starts_with(part: String) bool {
        if part.bytes > this.bytes : return false
        return mem:equal(this.data, part.data, part.bytes)
    }
    fn ends_with(part: String) bool {
        if part.bytes > this.bytes : return false
        return mem:equal(@ptr_offset(this.data, this.bytes - part.bytes), part.data, part.bytes)
    }

    /////////////////////
    // Index of
    /////////////////////

    fn byte_index_of_byte(byte: u8, start_index: uint (0)) uint !not_found {
        let index = start_index;
        let len = this.bytes;
        let data = this.data;
        while index < len {
            let ch = @ptrv(data, u8, index);
            if ch == byte : return index;
            index++;
        }
        throw not_found;
    }

    fn byte_index_of(part: String, start_index: uint (0)) uint !not_found {
        let part_bytes = part.bytes
        if part_bytes > this.bytes : throw not_found
        let index = start_index;
        let len = this.bytes - part_bytes + 1;
        let data = this.data;
        let part_data = part.data;
        while index < len {
            if mem:equal(@ptr_offset(data, index), part_data, part_bytes) : return index
            index++;
        }
        throw not_found;
    }

    fn index_of(part: String, start_index: uint (0)) uint !not_found {
        if part.bytes > this.bytes : throw not_found
        let step = @stack(CharStep)
        step.set(this)
        let count : uint = 0
        let offset : uint = 0
        let adr = this.data
        let part_adr = part.data
        let part_bytes = part.bytes
        let last_offset = this.bytes - part_bytes
        while count < start_index {
            offset += step.next() ! throw not_found
            if offset > last_offset : throw not_found
            count++
        }
        while true {
            if mem:equal(@ptr_offset(adr, offset), part_adr, part_bytes) : return count
            offset += step.next() ! throw not_found
            if offset > last_offset : throw not_found
            count++
        }
        return 0
    }

    fn contains(part: String) bool {
        this.index_of(part) ! return false
        return true
    }

    /////////////////////
    // Clean
    /////////////////////

    fn trim(part: String, limit: uint (0)) String {
        let res = this.ltrim(part, limit)
        return res.rtrim(part, limit)
    }

    fn rtrim(part: String, limit: uint (0)) String {

        let part_bytes = part.bytes
        let part_data = part.data

        let data = this.data
        let len = this.bytes
        let data_end = data + len
        let offset : uint = 0
        let count : uint = 0
        while (offset + part_bytes <= len) && mem:equal(data_end - offset - part_bytes, part_data, part_bytes) {
            offset += part_bytes
            count++
            if count == limit : break
        }
        if offset == 0 : return this

        return String.make_from_ptr(data, len - offset)
    }

    fn ltrim(part: String, limit: uint (0)) String {
        let part_bytes = part.bytes
        let part_data = part.data

        let data = this.data
        let len = this.bytes
        let offset : uint = 0
        let count : uint = 0
        while (offset + part_bytes <= len) && mem:equal(data + offset, part_data, part_bytes) {
            offset += part_bytes
            count++
            if count == limit : break
        }
        if offset == 0 : return this

        return String.make_from_ptr(data + offset, len - offset)
    }

    /////////////////////
    // Convert
    /////////////////////

    fn to_uint() uint !not_a_number {
        let i = this.bytes;
        let result : uint = 0;
        let mult : uint = 1;
        while i > 0 {
            i--;
            let ch = this.byte(i);
            if(ch < 48 || ch > 57){
                throw not_a_number;
            }
            result += ((ch @as uint) - 48) * mult;
            mult *= 10;
        }
        return result;
    }
    fn to_lower() String {
        let len = this.bytes
        let data = this.data;
        let new_str = String.make_empty(len);
        let new_data = new_str.data;
        while len-- > 0 {
            let ch = @ptrv(data, u8, len)
            if ch > 64 && ch < 91 : ch += 32
            @ptrv(new_data, u8, len) = ch
        }
        return new_str
    }

    /////////////////////
    // Partials
    /////////////////////
    
    fn byte(index: uint) u8 {
        if index >= this.bytes : return 0
        return @ptrv(this.data, u8, index)
    }
    fn byte_end(index: uint) u8 {
        if index >= this.bytes : return 0
        return @ptrv(this.data, u8, this.bytes - index - 1)
    }
    fn char(index: uint) String {
        return this.sub_str(index, 1)
    }
    fn char_end(index: uint) String {
        let len = this.chars()
        if index >= len : return ""
        return this.sub_str(len - index - 1, 1)
    }

    fn byte_sub_str(start_index: uint, length: uint) String {
        let this_bytes = this.bytes
        if start_index > this_bytes : return ""
        if (start_index + length) > this_bytes {
            length = this_bytes - start_index
        }
        if length == 0 : return ""
        let from = this.data + start_index
        let res = String.make_empty(length)
        mem:copy(from, res.data, length)
        return res
    }

    fn sub_str(start_index: uint, length: uint) String {

        if length == 0 : return ""
        let this_bytes = this.bytes
        if start_index > this_bytes : return ""

        let step = @stack(CharStep)
        step.set(this)

        let count : uint = 0
        let offset : uint = 0
        let data = this.data
        while count < start_index {
            offset += step.next() ! return ""
            count++
        }
        let start = offset
        count = 0
        while count++ < length {
            offset += step.next() ! break
            if offset >= this_bytes : break
        }
        if offset > this_bytes : offset = this_bytes
        return String.make_from_ptr(@ptr_offset(data, start), offset - start)
    }

    // fn split(on: String) Array[String] {
    //     let result = Array[String].new()
    // }

    fn split(on: String) Array[String] {
        let result = Array[String].new()

        let pos : uint = 0
        let adr = this.data
        let adr_on = on.data
        let bytes = this.bytes
        let bytes_left = bytes
        let bytes_on = on.bytes

        let part = utils:ByteBuffer.new(100)
        while pos < bytes {
            if(bytes_on > bytes_left){
                break
            }
            let i : uint = 0
            let tmp_adr1 = adr
            let tmp_adr2 = adr_on
            while(i < bytes_on){
                let byte1 : u8 = @ptrv(tmp_adr1, u8, 0)
                let byte2 : u8 = @ptrv(tmp_adr2, u8, 0)
                if(byte1 != byte2) {
                    break
                }
                i++
                tmp_adr1+=1
                tmp_adr2+=1
            }
            if(i == bytes_on){
                result.push(part.to_string())
                part.clear()
                pos += bytes_on
                adr += bytes_on
                bytes_left -= bytes_on
                continue
            }

            let bytec : u8 = 1
            let byte : u8 = @ptrv(adr, u8, 0)
            if(byte > 127){
                byte = byte << 1
                while(byte > 127){
                    bytec++
                    byte = byte << 1
                }
            }
            if(bytec > 4){
                // Invalid utf8 char
                bytec = 1
            }
            if(bytec > bytes_left){
                break
            }
            pos += bytec
            bytes_left -= bytec
            while(bytec > 0){
                let byte : u8 = @ptrv(adr, u8, 0)
                part.append_byte(byte)
                bytec--
                adr+=1
            }
        }
        while bytes_left > 0 {
            let byte : u8 = @ptrv(adr, u8, 0)
            part.append_byte(byte)
            bytes_left--
            adr+=1
        }

        result.push(part.to_string())

        return result
    }

    fn split_on_first_occurance_of_byte(byte: u8) (String, String) !not_found {
        let pos = this.byte_index_of_byte(byte) ! throw not_found
        let p2 = this.byte_sub_str(pos + 1, this.bytes - pos - 1)
        let p1 = this.byte_sub_str(0, pos)
        return p1, p2
    }

    /////////////////////
    // Misc
    /////////////////////

    // Convert escaped characters
    fn unescape() String {
        let bytes = this.bytes
        if bytes == 0 : return ""
        let data = this.data
        let buf = utils:ByteBuffer.new(bytes)
        //
        let i : uint = 0
        while i < bytes {
            let ch = @ptrv(data, u8, i++)
            if (ch == '\\') {
                let ch = @ptrv(data, u8, i++)
                ch = ch.unescape()
                buf.append_byte(ch)
                continue
            }
            buf.append_byte(ch)
        }
        return buf.to_string()
    }

    /////////////////////
    // Create
    /////////////////////

    fn clone() String {
        return String.make_from_ptr(this.data, this.bytes)
    }

    // TODO: mark unsafe
    static fn make_empty(length: uint) String {
        if length == 0 : return ""
        let d = mem:alloc(length + 1)
        @ptrv(d, u8, length) = 0 // trailing 0 byte
        let str = String {
            data: d
            bytes: length
        }
        return str
    }

    // TODO: mark unsafe
    static fn make_from_ptr(data: ptr, length: uint) String {
        if length == 0 : return ""
        let s = String.make_empty(length)
        mem:copy(data, s.data, length)
        return s
    }

    /////////////////////
    // Internals
    /////////////////////

    fn _add(add: String) String {
        let this_len = this.bytes
        let add_len = add.bytes
        let len = this_len + add_len
        if len == 0 : return ""
        let s = SELF.make_empty(len)
        let data = s.data
        mem:copy(this.data, data, this_len)
        mem:copy(add.data, @ptr_offset(data, this_len), add_len + 1) // + 1 for 0 byte
        return s
    }

    fn _eq(cmp: String) bool {
        if this.bytes != cmp.bytes : return false 
        return mem:equal(this.data, cmp.data, this.bytes)
    }

    fn _gc_free() {
        mem:free(this.data)
    }
}
