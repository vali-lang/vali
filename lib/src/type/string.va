
use mem
use utils

- struct StringConst {
    v1: u8 (0)
    v2: u8 (0)
    v3: u8 (0)
    v4: u8 (0)
    v5: u32 (0)
    data: ptr
    bytes: uint
}

class String {
    data: ptr
    bytes: uint

    /////////////////////
    // UTF8
    /////////////////////

    fn utf8_count() uint {
        let count : uint = 0
        let pos : uint = 0
        let adr = this.data
        let bytes = this.bytes
        while pos < bytes {
            let bytec : u8 = 1
            let byte : u8 = @ptrv(adr, u8, pos)
            if((byte & 128) > 0){
                byte = byte << 1
                while (byte & 128) > 0 {
                    bytec++
                    byte = byte << 1
                }
            }
            if(bytec > 4) : bytec = 4
            count++
            pos += bytec
        }
        return count
    }

    // fn utf8_string() StringUtf8 {
    //     return 0
    // }

    // fn utf8_clean_corrupt_characters() {
    // }

    /////////////////////
    // Clean
    /////////////////////

    fn trim(part: String) String {
        let res = this.ltrim(part)
        return res.rtrim(part)
    }

    fn rtrim(part: String) String {

        let part_bytes = part.bytes
        let part_data = part.data

        let data = this.data
        let len = this.bytes
        let data_end = data + len
        let offset : uint = 0
        while (offset + part_bytes <= len) && mem:equal(data_end - offset - part_bytes, part_data, part_bytes) {
            offset += part_bytes
        }
        if offset == 0 : return this

        return String.make_from_ptr(data, len - offset)
    }

    fn ltrim(part: String) String {
        let part_bytes = part.bytes
        let part_data = part.data

        let data = this.data
        let len = this.bytes
        let offset : uint = 0
        while (offset + part_bytes <= len) && mem:equal(data + offset, part_data, part_bytes) {
            offset += part_bytes
        }
        if offset == 0 : return this

        return String.make_from_ptr(data + offset, len - offset)
    }

    /////////////////////
    // Convert
    /////////////////////

    fn to_uint() uint !not_a_number {
        let i = this.bytes;
        let result : uint = 0;
        let mult : uint = 1;
        while i > 0 {
            i--;
            let ch = this.byte(i);
            if(ch < 48 || ch > 57){
                throw not_a_number;
            }
            result += ((ch @as uint) - 48) * mult;
            mult *= 10;
        }
        return result;
    }
    fn to_lower() String {
        let bytes = this.bytes;
        let data = this.data;
        let new_str = String.make_empty(bytes);
        let new_data = new_str.data;
        let pos : uint = 0;
        while pos < bytes {
            let byte : u8 = @ptrv(data, u8, pos);
            if byte > 127 {
                @ptrv(new_data, u8, pos) = byte;
                pos++;
                continue;
            }
            let is_upper = (byte > 64 && byte < 91) ? 1 @as u8 : 0 @as u8;
            @ptrv(new_data, u8, pos) = byte + (is_upper * 32);
            pos++;
        }
        return new_str;
    }

    /////////////////////
    // Partials
    /////////////////////
    
    fn byte(index: uint) u8 {
        if index >= this.bytes : return 0
        return @ptrv(this.data, u8, index)
    }

    fn sub_str_bytes(byte_start_index: uint, byte_length: uint) String {

        let this_bytes = this.bytes
        if(byte_start_index > this_bytes){
            return ""
        }
        if((byte_start_index + byte_length) > this_bytes){
            byte_length = this_bytes - byte_start_index
        }
        if(byte_length == 0){
            return ""
        }
        let from = this.data + byte_start_index
        let res = String.make_empty(byte_length)
        mem:copy(from, res.data, byte_length)
        return res
    }

    fn split(on: String) Array[String] {
        let result = Array[String].new()

        let pos : uint = 0
        let adr = this.data
        let adr_on = on.data
        let bytes = this.bytes
        let bytes_left = bytes
        let bytes_on = on.bytes

        let part = utils:ByteBuffer.new(100)
        while pos < bytes {
            if(bytes_on > bytes_left){
                break
            }
            let i : uint = 0
            let tmp_adr1 = adr
            let tmp_adr2 = adr_on
            while(i < bytes_on){
                let byte1 : u8 = @ptrv(tmp_adr1, u8, 0)
                let byte2 : u8 = @ptrv(tmp_adr2, u8, 0)
                if(byte1 != byte2) {
                    break
                }
                i++
                tmp_adr1+=1
                tmp_adr2+=1
            }
            if(i == bytes_on){
                result.push(part.to_string())
                part.clear()
                pos += bytes_on
                adr += bytes_on
                bytes_left -= bytes_on
                continue
            }

            let bytec : u8 = 1
            let byte : u8 = @ptrv(adr, u8, 0)
            if(byte > 127){
                byte = byte << 1
                while(byte > 127){
                    bytec++
                    byte = byte << 1
                }
            }
            if(bytec > 4){
                // Invalid utf8 char
                bytec = 1
            }
            if(bytec > bytes_left){
                break
            }
            pos += bytec
            bytes_left -= bytec
            while(bytec > 0){
                let byte : u8 = @ptrv(adr, u8, 0)
                part.append_byte(byte)
                bytec--
                adr+=1
            }
        }
        while bytes_left > 0 {
            let byte : u8 = @ptrv(adr, u8, 0)
            part.append_byte(byte)
            bytes_left--
            adr+=1
        }

        result.push(part.to_string())

        return result
    }

    /////////////////////
    // Create
    /////////////////////

    fn clone() String {
        return String.make_from_ptr(this.data, this.bytes)
    }

    // TODO: mark unsafe
    static fn make_empty(length: uint) String {
        if length == 0 : return ""
        let d = mem:gc_bump_alloc(length + 1)
        @ptrv(d, u8, length) = 0 // trailing 0 byte
        let str = String {
            data: d
            bytes: length
        }
        return str
    }

    // TODO: mark unsafe
    static fn make_from_ptr(data: ptr, length: uint) String {
        if length == 0 : return ""
        let s = String.make_empty(length)
        mem:copy(data, s.data, length)
        return s
    }

    /////////////////////
    // Internals
    /////////////////////

    fn _add(add: String) String {
        let this_len = this.bytes
        let add_len = add.bytes
        let len = this_len + add_len
        if len == 0 : return ""
        let s = CLASS.make_empty(len)
        let data = s.data
        mem:copy(this.data, data, this_len)
        mem:copy(add.data, @ptr_offset(data, this_len), add_len + 1) // + 1 for 0 byte
        return s
    }

    fn _eq(cmp: String) bool {
        if this.bytes != cmp.bytes : return false 
        return mem:equal(this.data, cmp.data, this.bytes)
    }

    fn _gc_transfer() {
        // Copy data from bump allocator to malloc
        let data = this.data
        let bytes = this.bytes + 1
        let new = mem:alloc(bytes)
        mem:copy(data, new, bytes)
        this.data = new
    }

    fn _gc_free() {
        // Free data if data was transfered
        let data = this.data
        if @ptrv(this, u8, -8) > 2 {
            mem:free(data)
        }
    }
}
