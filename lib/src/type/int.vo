
use volt:mem

integer int {

    fn to_str() string {
        if this < 0 {
            return "negative"
        }
        let x = this @as uint
        return x.to_str()
    }

    // fn str_base(base: u8) string {

	// 	let negative = false;
    //     let num = this;

    //     // Handle 0 explicitly, otherwise empty string is printed for 0
    //     if (num == 0) {
    //         return "0";
    //     }

	// 	// In standard itoa(), negative numbers are handled only with
    //     // base 10. Otherwise numbers are considered unsigned.
    //     if (num < 0 && base == 10) {
    //         negative = true;
    //         num *= -1;
    //     }
 
    //     let abs = num @as uxx;
 
    //     // Process individual digits
    //     let buf_adr = mem:alloc(32);
    //     let len : u32 = 0;
    //     let ch : u8 = 0;
    //     while (abs != 0) {
    //         let rem : u8 = (abs % base) @as u8;
    //         if(rem > 9){
    //             ch = (rem-10) + 'a';
    //         } else {
    //             ch = rem + '0';
    //         }
	// 		@ptrv(buf_adr, u8, 0) = ch;
    //         buf_adr++;
    //         len++;
    //         abs = abs/base;
    //     }

    //     if (negative) {
    //         @ptrv(buf_adr, u8, 0) = '-';
    //         buf_adr++;
    //         len++;
    //     }
 
    //     // Reverse the string
    //     let str = String.make_empty(len);
    //     let str_adr = str.data();
    //     while(len > 0){
    //         len-=1;
    //         buf_adr-=1;
	// 		@ptrv(str_adr, u8, 0) = @ptrv(buf_adr, u8, 0);
    //         str_adr+=1;
    //     }
    //     return str;
    // }
}
