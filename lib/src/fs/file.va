
header "sys" as sys

use mem
use io
use utils

fn open(path: String, writable: bool, append_on_write: bool) FD !open {
    return open_extend(path, writable, append_on_write, false) ! throw open
}
// TODO: use octal number for permissions
fn open_extend(path: String, writable: bool, append_on_write: bool, create_file_if_doesnt_exist: bool (false), create_file_permissions: u32 (420)) FD !open {

    let flags : i32 = sys:O_RDONLY
    if writable : flags = sys:O_RDWR
    if create_file_if_doesnt_exist : flags = flags | sys:O_CREATE
    if append_on_write : flags = flags | sys:O_APPEND

    let fd = sys:open(path.data, flags, create_file_permissions);
    if fd < 0 {
        throw open;
    }
    return fd @as FD;
}

fn stat(path: String, buf: sys:libc_stat) void !failed {
    let res = sys:stat(path.data, buf)
    if res == -1 : throw failed
}
fn size(path: String) uint {
    let buf = @stack(sys:libc_stat)
    stat(path, buf) ! return 0
    return buf.st_size @as uint
}

// fn read(path: String) String !open !read !close {

// 	let fd = open(path, true, false) ! throw open

// 	let res = utils:ByteBuffer.new(4096)
// 	while true {
//         res.minimum_free_space(4096)
// 		let readcount = sys:read(fd, res.data + res.length, 4096)
// 		if(readcount < 0){
// 			throw read
// 		}
//         res.length += readcount @as uint;
// 		if(readcount != 4096) {
// 			break
// 		}
// 	}

// 	let check = sys:close(fd)
// 	if(check != 0){
// 		//throw close
// 	}

// 	return res.to_string()
// }

// TODO: !open instead of !open_err (err identifiers need to be split)
fn write(path: String, content: String, append: bool (true)) void !open_err {

    let flags = sys:O_TRUNC
    if append : flags = sys:O_APPEND

    let fd = open_extend(path, true, append, true) ! throw open_err

    // TODO: ignore error handler
    io:write(fd, content) ! {
        io:close(fd)
        return
    }
    io:close(fd)
}

fn exists(path: String) bool {
    let fd = open(path, false, false) ! return false
    io:close(fd)
    return true
}
fn delete(path: String) void !failed {
    let res = sys:unlink(path.data)
    if res == -1 {
        throw failed
    }
}
fn mkdir(path: String) void !failed {

    // TODO: use octal numbers
    let res = sys:mkdir(path.data, 493) // 0755
    if res == -1 {
        throw failed
    }
}

fn is_file(path: String) bool {
    let buf = @stack(sys:libc_stat)
    stat(path, buf) ! return false
    return (buf.st_mode & sys:S_IFMT) == sys:S_IFREG
}
fn is_dir(path: String) bool {
    let buf = @stack(sys:libc_stat)
    stat(path, buf) ! return false
    return (buf.st_mode & sys:S_IFMT) == sys:S_IFDIR
}

fn files_in(directory: String, files: bool (true), dirs: bool (true)) Array[String] {
    let result = Array[String].new()

    #if OS == win

    let path = directory.rtrim("/") + "/*"
    let pattern = path.data
    let data = @stack(sys:WIN32_FIND_DATAA)
    let hFind = sys:FindFirstFileA(pattern, data)
    if hFind != -1 @as ptr {
        let loop = true
        while loop {
            let fn = (@ptr_of(data.cFileName) @as c_string).to_str()

            if fn.bytes < 3 && (fn == "." || fn == "..") {
                loop = sys:FindNextFileA(hFind, data)
                continue
            }

            let is_dir = (data.dwFileAttributes & 0x10) > 0
            let is_file = !is_dir

            if (dirs && is_dir) || (files && is_file) {
                result.push(path + fn)
            }

            loop = sys:FindNextFileA(hFind, data)
        }
        sys:FindClose(hFind)
    }

    #else

    let dir = directory.rtrim("/") + "/"
    let d = sys:opendir(dir.data)

    if isset(d) {
        while true {
            let ent = sys:readdir(d)
            if isset(ent) {
                let fn = (@ptr_of(ent.d_name) @as cstring).to_str()
                if fn.bytes < 3 && (fn == "." || fn == "..") {
                    continue
                }
                let fpath = dir + fn

                let _is_dir = is_dir(fpath)
                let _is_file = !_is_dir

                if (dirs && _is_dir) || (files && _is_file) {
                    result.push(fpath)
                }
                continue
            }
            break

        }
        sys:closedir(d)
    }

    #end

    return result
}
